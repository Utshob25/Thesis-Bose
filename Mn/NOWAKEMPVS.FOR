            PROGRAM VMHNC
C     PROGRAM TO SOLVE HNC OR PY EQUATION FOR A TWO
C     COMPONENT MIXTURE
C
      IMPLICIT REAL*8 (A-H,O-Z)
C      PARAMETER(MX=4096,NX=2048,NB=50)
      PARAMETER(MX=1024,NX=512,NB=50)
C
      COMMON/SEG/XXSEG,XKSEG,NSEG
      COMMON/ND/NDIM1,NDIM2,NDIM3
      COMMON/NB2/NBAS1(10),NBAS2(10),NBAS3(10)
      COMMON/AB/ABAS1(10,10),ABAS2(10,10),ABAS3(10,10)
      COMMON/BB/BBAS1(10,10),BBAS2(10,10),BBAS3(10,10)
      COMMON/CB/CBAS1(10),CBAS2(10),CBAS3(10)
      COMMON/DB/DBAS1(10),DBAS2(10),DBAS3(10)
      COMMON/QB/QBAS1(10,100),QBAS2(10,100),QBAS3(10,100)
      COMMON/PB/PBAS1(10,100),PBAS2(10,100),PBAS3(10,100)
      COMMON/X/X1(MX),X2(MX),X3(MX)
      COMMON/Y/Y1(MX),Y2(MX),Y3(MX)
      COMMON/POT/VPOT1(MX),VPOT2(MX),VPOT3(MX)
      COMMON/JAC/AJAC(10,10),NJAC
      COMMON/DEN/DEN1,DEN2
      COMMON/RR/R1,R2
      COMMON/BS/ABAS(10,10),BBAS(10,10),PBAS(10,100)
      COMMON/BS/QBAS(10,100),LMAX
      COMMON/CRS/CBAS(10)
      COMMON/FIN/NPRINT,NREM,Y(MX),DBAS(10)
      COMMON/NR/STEP,ACC,NRIT
      COMMON/COUNT/NCNT,MODE,ACCTOT
      COMMON/ID/IEND
      COMMON/NH/NHS
      COMMON/NP/NPOT
      COMMON/ZT/Z1,Z2,T,ZREAL
      COMMON/II/INDEX,DELTA,INXTAL
      COMMON/YBG/YR(MX),BR(MX),GMK(MX)
      COMMON/HRK/HR(MX),GR(MX),HK(MX)
      COMMON/BXW/BX(MX),BWORK(MX),BD(2,MX),DD(2)
      COMMON/EX/ET(0:100),XI(0:100),EW(4),XW(4)
      COMMON/EF/XFR(50),FFR(50),XM(3),FM(3)
      COMMON/VB/VBARE(3,MX),TAL(20),TIN,TTR
      COMMON/SNO/CK(MX),CR(MX)
      COMMON/CORE/RDC
      COMMON/BH/ETA,DENS
      DIMENSION YF(2048),VK(200),SK(200),FFPS(200),XINTEG(200),CONQ(200)
     
C
      PI=3.1415926530

      NREMIT=100
      IDIM=0
      NH=NX/2

      OPEN(1,FILE='PSEUDOPT.DAT',STATUS='OLD')
      READ(1,*)TIN,TTR

      READ(1,*)RC1,RC2
      READ(1,*)Z1,Z2
      READ(1,*)DENS,C1
      READ(1,*)MAXQ,DROLD
      READ(1,*)MAXR
      READ(1,*)ISTEP
      READ(1,*)DELTA,ERR
      READ(1,*)AA1,BB1
      READ(1,*)AA2,BB2
      READ(1,*) AX
      CLOSE(1)
      ZREAL=Z1
      Z1=0.0
      Z2=0.0
      XI(0)=0.0
      ET(0)=0.0

      WRITE(*,987)AA1,AA2,BB1,BB2
  987 FORMAT(1X,'A1 A2 B1 B2== ',4(1X,F10.6))


      NSEG=NX
      DO 123 J=1,NSEG
        VBARE(1,J)=0.0
        VBARE(2,J)=0.0
        VBARE(3,J)=0.0
  123 CONTINUE

C     VFEED GIVES THE POTENTIAL. IF WE PUT ITYPE =2 WE WILL HAVE A LJ TYPE
C     POTENTIAL AND A VALUE MUST BE GIVEN TO SGLJ. IF ITYPE IS ANOTHER
C     NATURAL NUMBER THEN WE WILL WORK WITH THE POTENTIAL OF FOR001
C
      ITYPE = 1
      SGLJ = 3.405
      IF(ITYPE.NE.2)GOTO 1234
      XXSEG=DROLD
 1234 CONTINUE
C
      CALL VFEED(ITYPE,NX,DENS,SGLJ)
C      BBSG=0.50*XXSEG
C      XXSG=XXSEG

      OPEN(1,FILE='DELTA.DAT',STATUS='OLD')
1244  READ(1,*,END=1245)I,XI(I),ET(I)
      GOTO 1244
1245  CONTINUE
      CLOSE(1)

C      XXSEG=BBSG
C      CALL BRIDGE(NX,NB,DENS,PI)
C      XXSEG=XXSG
C

      WRITE(*,666)DELTA,ERR
  666 FORMAT(1X,'DELTA ERR== ',2E20.12)
      WRITE(*,600)
      GO TO (107,108),MODE
  107 WRITE(*,601) MODE
      GO TO 109
  108 WRITE(*,602) MODE
  109 WRITE(*,603) DENS
      WRITE(*,604) R1,R2
      WRITE(*,605) Z1,Z2
      WRITE(*,606)TIN,TTR
      WRITE(*,607) NSEG
      WRITE(*,608) XXSEG
      WRITE(*,615)STEP
      WRITE(*,616) ACC
      WRITE(*,617) ACCTOT
C
C     CONSTANTS AND CHECKS
C
      PI = 3.14159265
      XPN=1.0/3.0
      DHS=(6.0*ETA/(PI*DENS))**XPN
      XKSEG = 2.0*PI/(FLOAT(NSEG)*XXSEG)
      DEN1=C1*DENS
      DEN2=(1.0-C1)*DENS
  118 IF (R2.LT.R1) GO TO 133
      DO 1000 I=0,NX
        BR(I)=0.0
 1000 CONTINUE

C     CUTOUT=10000.0
      INXTAL=1
      T=TIN
      CALL BSETUP
      IF(TIN.EQ.TTR)GO TO 555
      ETA=0.0
 1001 CONTINUE
C     CALL POTEN(NX)
      CALL POTEN
      WRITE(*,633)T
      CALL FINCRS
      CALL FINAL(X1,VPOT1,MODE,NX,PI)
      INXTAL=INXTAL+1
C       OPEN (53,FILE='INIT5',STATUS='NEW')
        OPEN (53,FILE='INIT5')
        DO I=1,NX/2
                WRITE (53,*)X1(I)
        ENDDO
        CLOSE (53)
      IF(TAL(INXTAL).LT.1.0)GO TO 1001
  555 CONTINUE

      BFMIN=100.0
      BSTEP=0.0200
      ECUT=0.490
C      ETA=0.00
      ETA = 0.26
      INF=0
      FOLD=100000.0

  700 CONTINUE
      INF=INF+1
      XFR(INF)=ETA
      FFR(INF)=BFMHNC(NX,NB,ETA,PI,DENS,X1,VPOT1,MODE)
      FNEW=FFR(INF)

      SKK=1.0/(1.0-DENS*CK(1))
      WRITE(*,733)ETA,SKK
  733 FORMAT(1X,'ETA SK(1)=== ',F10.6,2X,E20.12)

      IF(FFR(INF).GT.BFMIN)GO TO 711
      MIN=INF
      BFMIN=FFR(INF)
  711 CONTINUE
      IF(ETA.GE.0.38)BSTEP=0.010
      ETA=ETA+BSTEP
C     IF(ETA.LE.ECUT)GO TO 700
      IF(FNEW.GT.FOLD)GO TO 766
      FOLD=FNEW
C       OPEN (53,FILE='INIT5',STATUS='NEW')
        OPEN (53,FILE='INIT5')
       DO I=1,NX/2
              WRITE (53,*)X1(I)
       ENDDO
      CLOSE (53)
      GO TO 700
  766 CONTINUE

C      WRITE(75,789)MIN,XFR(MIN),FFR(MIN)
C  789 FORMAT(1X,I4,2X,'MIN ETA BF== ',F10.6,2X,E20.12)

      CALL INTERP(NX,NB,PI,DENS,X1,VPOT1,MODE,MIN,INF,ERR,BSTEP)
C

C       OPEN (53,FILE='INIT5',STATUS='NEW')
        OPEN (53,FILE='INIT5')
        DO I=1,NX/2
                WRITE (53,*)X1(I)
        ENDDO
        CLOSE(53)
        OPEN(75,FILE='STRUCEMPVS.DAT',STATUS='UNKNOWN')
cc      WRITE (75,*)'  RESULTS USING ASHCROFT''S PSEUDOPOTENTIALS'

cc      WRITE (75,*)' '

cc      WRITE(75,7890)RC1,TTR
cc   7890 FORMAT(5X,'RESULTS FOR A RC=',E20.10,5X,'AND
cc      *  TEMPERATURE=',E20.10,/)
c        WRITE(75,7891)
CC 7891 FORMAT(4X,'R(ANST)',7X,'G(R)',15X,'K',16X,'S(K)',20X,
CC     * 'H(K)',20X,'V(R)/KT',///)
      NLL=200
      DO 777 I=1,NLL
        VR=(I-1)*XXSEG
        VK(I)=(I-1)*XKSEG
        SK(I)=1.0/(1.0-DENS*CK(I))
        WRITE(75,898)VR,GR(I),VK(I),SK(I),HK(I),VPOT1(I)
  777 CONTINUE
C
      OPEN(1,FILE='FOR053.DAT',STATUS='OLD')
7770  READ(1,*,END=7771)II,CONQ(II),FFPS(II)
      GO TO 7770
7771  CONTINUE
      CLOSE(1)
C      COMPUTATION OF THE RESISTIVITY USING ZIMAN'S FORMULA
      DO 778 I =1,NLL
         VK(I)=(I-1)*XKSEG
         SK(I)=1.0/(1.0-DENS*CK(I))
         XINTEG(I)=(VK(I)**3.0)*(FFPS(I)**2.0)*SK(I)
  778 CONTINUE
C
C    FERMI WAVEVECTOR
      FQ=(3.0*(PI**2.0)*DENS*ZREAL)**XPN
      PUNT=2.0*FQ/XKSEG + 0.5
      NPUNT=INT(PUNT)
      CALL D01GAF(VK,XINTEG,NPUNT,ANS)
CC      WRITE(75,7781)NPUNT,ANS
CC 7781 FORMAT(5X,'NPUNT=',I5, 3X,'INTEGRAL FOR THE RESISTIVITY=',F16.9)
C   COMPUTATION OF THE TOTAL RESISTIVITY
      CT1=1.685175114/1000000.0
      CT2=0.529177*ZREAL**2
      REST=CT1*ANS/((FQ**5.0)*CT2)
CC      WRITE(75,7782)REST
CC 7782 FORMAT(15X,'RESISTIVITY=',E20.12,5X,'IN OHMS X M',/)

      NH=NX/2
  888 FORMAT(1X,I5,2X,F10.6,2X,5E20.12)
  898 FORMAT(1X,F10.6,2X,E20.12,2X,F10.6,3(2X,E20.12))

  999 CONTINUE
  133 CONTINUE
      STOP
  500 FORMAT(6X,10I5)
  501 FORMAT(6X,2F15.6)
  502 FORMAT(6X,E15.6)
  600 FORMAT(1H0,28X,'PROGRAM TO SOLVE PY OR HNC INTEGRAL ',
     >      'EQUATION FOR TWO COMPONENT SYSTEM'/1H ,28X,69('*'))
  601 FORMAT(1H0,'MODE =',I2,' (IN THIS RUN THE PY',
     >      ' EQUATION IS TO BE SOLVED)')
  602 FORMAT(1H0,'MODE =',I2,' (IN THIS RUN THE HNC',
     >      ' EQUATION IS TO BE SOLVED)')
  603 FORMAT(1H0,'NUMBER DENSITY OF PARTICLES =',F10.6)
  604 FORMAT(1H0,'HARD-SPHERE DIAMETERS OF PARTICLES ARE',
     >      ' R1 =',F10.6,5X,' R2 =',F10.6)
  605 FORMAT(1H0,'CHARGES OF PARTICLES ARE Z1 =',F5.1,5X,
     >      ' Z2 =',F5.1)
  606 FORMAT(1H0,'TEMPERATURE OF SYSTEM  TIN TTR=',2(2X,F10.3))
  607 FORMAT(1H0,'NUMBER OF MESH POINTS =',I5)
  608 FORMAT(1H0,'MESH LENGTH IN REAL SPACE =',F10.6)
  615 FORMAT(1H0,'MAXIMUM STEP LENGTH IN N-R ITERATIONS IS',
     >      E15.6)
  616 FORMAT(1H0,'ACCURACY OF N-R PROCEDURE',E15.6)
  617 FORMAT(1H0,'TOTAL ACCURACY',E15.6)
  633 FORMAT(1X,'TEMP==.... ',F10.3)
      END
C
C
C
C
      BLOCK DATA
      IMPLICIT REAL*8(A-H,O-Z)
C      PARAMETER(MX=4096)
      PARAMETER(MX=1024)
      COMMON/COUNT/NCNT,MODE,ACCTOT
C      COMMON/COUNT/ACCTOT,NCNT,MODE
      COMMON/RR/R1,R2
      COMMON/ZT/Z1,Z2,T,ZREAL
      COMMON/SEG/XXSEG,XKSEG,NSEG
      COMMON/ND/NDIM1,NDIM2,NDIM3
      COMMON/NB2/NBAS1(10),NBAS2(10),NBAS3(10)
      COMMON/NR/STEP,ACC,NRIT
      COMMON/FIN/NPRINT,NREM,Y(MX),DBAS(10)
      COMMON/NP/NPOT
      COMMON/NH/NHS
      COMMON/JAC/AJAC(10,10),NJAC
      COMMON/VB/VBARE(3,1024),TAL(20),TIN,TTR
C
      DATA MODE/2/
C     DATA R1,R2/0.90,0.90/
      DATA R1,R2/2.5,2.5/
      DATA NDIM1,NDIM2,NDIM3/8,8,8/
      DATA (NBAS1(I),I=1,8)/10,30,50,62,67,71,75,79/
      DATA (NBAS2(I),I=1,8)/10,30,50,62,67,71,75,79/
      DATA (NBAS3(I),I=1,8)/10,30,50,62,67,71,75,79/
C      DATA NDIM1,NDIM2,NDIM3/10,10,10/
C      DATA (NBAS1(I),I=1,10)/15,35,70,75,78,81,85,88,91,95/
C      DATA (NBAS2(I),I=1,10)/15,35,70,75,78,81,85,88,91,95/
C      DATA (NBAS3(I),I=1,10)/15,35,70,75,78,81,85,88,91,95/
      DATA NRIT/100/
      DATA STEP/2.236/
      DATA ACC/1.0E-5/
      DATA ACCTOT/5.0E-7/
      DATA NPRINT/0/
      DATA NPOT,NHS,NJAC/0,0,0/
C     DATA (TAL(L),L=1,3)/0.0,0.50,1.0/
C      DATA (TAL(I),I=1,20)/0.0,0.20,0.40,0.60,0.70,0.80,0.850,0.90,0.92
C     * ,0.94,0.96,0.98,0.990,0.993,0.995,0.997
C     * ,0.998,0.999,0.9995,1.0/
C      DATA (TAL(K),K=1,8)/0.0,0.250,0.50,0.750,0.90,0.970,0.990,1.0/
C      DATA (TAL(I),I=1,12)/0.0,0.20,0.40,0.60,0.80,0.90,0.93,
C     * 0.96,0.98,0.99,0.995,1.0/
C      DATA (TAL(I),I=1,5)/0.0,0.450,0.800,0.9750,1.0/
C      DATA (TAL(I),I=1,6)/0.0,0.450,0.750,0.90,0.97,1.0/
      DATA (TAL(I),I=1,9)/0.0,0.30,0.60,0.80,0.90,0.93,0.96,0.985,1.0/
C     DATA (TAL(L),L=1,10)/0.0,0.20,0.40,0.60,0.80,0.90,0.930,0.960,0.990,1.0/
C      DATA (TAL(I),I=1,18)/0.0,0.25,0.50,0.65,0.8,0.90,0.93,0.96,0.98,
C     * 0.985,0.990,0.993,0.996,0.998,0.999,0.9995,0.9999,1.0/
      END
C
C
C
C
C      SUBROUTINE POTEN(NX)
      SUBROUTINE POTEN
      IMPLICIT REAL*8(A-H,O-Z)
C      PARAMETER(MX=4096)
      PARAMETER(MX=1024)
      COMMON/SEG/XXSEG,XKSEG,NSEG
      COMMON/POT/VPOT1(MX),VPOT2(MX),VPOT3(MX)
      COMMON/II/INDEX,DELTA,INXTAL
      COMMON/NP/NPOT
      COMMON/ZT/Z1,Z2,T,ZREAL
      COMMON/YBG/YR(MX),BR(MX),GMK(MX)
      COMMON/VB/VBARE(3,MX),TAL(20),TIN,TTR
C
      AL=TAL(INXTAL)
      T=(1.0-AL)*TIN+AL*TTR
      DO 1,I=2,NSEG
         VPOT1(I)=VBARE(1,I)/T+BR(I)
         VPOT2(I)=VPOT1(I)
         VPOT3(I)=VPOT1(I)
  1   CONTINUE
      VPOT1(1)=1.0D+30
      VPOT2(1)=1.0D+30
      VPOT3(1)=1.0D+30

      RETURN
      END
C
C
C
C
      SUBROUTINE BASIS(NBAS,NDIM)
      IMPLICIT REAL*8(A-H,O-Z)
      COMMON/AJS01/SBAS(10,100),BINV(10,10),WORK(10)
      COMMON/BS/ABAS(10,10),BBAS(10,10),PBAS(10,100)
      COMMON/BS/QBAS(10,100),LMAX
      DIMENSION NBAS(10),WKAREA(130)
C
      PRINT*,'NDIM=',NDIM
C
      RHO = NBAS(1)-1
      BBAS(1,1) = RHO*(RHO+1.0)*(2.0*RHO+1.0)
     >            /(6.0*RHO*RHO)
      ABAS(1,1) = BBAS(1,1)
      DO 1 I=2,NDIM
      AMB = RHO
      RHO = NBAS(I)-NBAS(I-1)
      BBAS(I,I) = AMB*(AMB+1.0)*(2.0*AMB+1.0)
     >            /(6.0*AMB*AMB)
     >           +RHO*(RHO+1.0)*(2.0*RHO+1.0)
     >            /(6.0*RHO*RHO)-1.0
      BBAS(I,I-1) = (AMB-1.0)*AMB*(AMB+1.0)/(6.0*AMB*AMB)
      ABAS(I,I) = BBAS(I,I)
      ABAS(I,I-1) = BBAS(I,I-1)
    1 CONTINUE
      DO 2 I=3,NDIM
      JMAX = I-2
      DO 2 J=1,JMAX
      BBAS(I,J) = 0.0
    2 CONTINUE
      DO 3 I=1,NDIM
      DO 3 J=1,I
      BBAS(J,I) = BBAS(I,J)
    3 CONTINUE
      NCON=10
      IFAIL = 0
      NDL1=NDIM
C      CALL F01ABF(BBAS,NCON,NDL1,BINV,NCON,WORK,IFAIL)
      CALL LINV2F(BBAS,NDL1,NCON,BINV,6,WKAREA,IFAIL)
      IF (IFAIL.NE.0) GO TO 104
      DO 4 I=1,NDIM
      DO 4 J=1,I
      BBAS(I,J) = BINV(I,J)
      BBAS(J,I) = BINV(I,J)
    4 CONTINUE
      LMAX = NBAS(NDIM)
      DO 5 L=1,LMAX
      DO 5 I=1,NDIM
      PBAS(I,L) = 0.0
    5 CONTINUE
      J1 = 1
      IF (NDIM.GT.1) J1=NBAS(NDIM-1)
      J2 = NBAS(NDIM)
      DSEG = J2-J1
      DO 7 J=J1,J2
      XL = 1.0-(FLOAT(J)-FLOAT(J1))/DSEG
      PBAS(NDIM,J) = XL
      DO 6 N=1,NDIM
      QBAS(N,J) = XL*BBAS(N,NDIM)
    6 CONTINUE
    7 CONTINUE
      IMAX = NDIM-1
      J2 = 1
      DO 10 I=1,IMAX
      J1 = J2
      J2 = NBAS(I)
      DSEG = J2-J1
      DO 9 J=J1,J2
      XL = 1.0-(FLOAT(J)-FLOAT(J1))/DSEG
      XR = 1.0-XL
      PBAS(I,J) = XL
      PBAS(I+1,J) = XR
      DO 8 N=1,NDIM
      QBAS(N,J) = XL*BBAS(N,I)+XR*BBAS(N,I+1)
    8 CONTINUE
    9 CONTINUE
   10 CONTINUE
C
C     LIST BASIS FUNCTIONS AND THEIR CONJUGATES
C
C
C     CHECK SCALAR PRODUCTS OF BASIS FUNCTIONS AND
C     THEIR CONJUGATES
C
      DO 13 I=1,NDIM
      DO 13 J=1,NDIM
      SBAS(I,J) = 0.0
   13 CONTINUE
      DO 14 I=1,NDIM
      DO 14 J=1,NDIM
      DO 14 L=1,LMAX
      SBAS(I,J) = SBAS(I,J)+PBAS(I,L)*QBAS(J,L)
   14 CONTINUE
      RETURN
  104 CONTINUE
      STOP
      END
C
C
C
C
      SUBROUTINE HS
      IMPLICIT REAL*8(A-H,O-Z)
C      PARAMETER(MX=4096)
      PARAMETER(MX=1024)
      REAL*8 IMZ
      COMMON/AJS02/Y1(MX),Y2(MX),Y3(MX)
      COMMON/AJS03/REZ(7),IMZ(7),COEF(7),WORK(MX)
      COMMON/SEG/XXSEG,XKSEG,NSEG
      COMMON/X/X1(MX),X2(MX),X3(MX)
      COMMON/DEN/DEN1,DEN2
      COMMON/RR/R1,R2
      COMMON/NH/NHS
      COMMON/ZT/Z1,Z2,T,ZREAL
      COMPLEX *16 COZ(7)
C
C     CONSTANTS
C
      PI = 3.14159265
      PI4 = 4.0*PI
      R1S = R1*R1
C      R1C = R1S*R1
C      R2S = R2*R2
C      R2C = R2S*R2
C      R = (R1+R2)/2.0
C      S = (R2-R1)/2.0
C      S2 = S*S
C      S3 = S2*S
C      S4 = S3*S
C      ETA1 = PI*DEN1/6.0
C      ETA2 = PI*DEN2/6.0
C      XI = ETA1*R1**3+ETA2*R2**3
C      XIA = (1.0-XI)**2
C      XIB = (1.0-XI)**3
C      XIC = 1.0+XI+XI*XI
C      GR1 = (1.0+0.5*XI+1.5*ETA2*R2*R2*(R1-R2))/XIA
C      GR2 = (1.0+0.5*XI+1.5*ETA1*R1*R1*(R2-R1))/XIA
C      GR12 = (R2*GR1+R1*GR2)/(2.0*R)
C      B = -6.0*R*GR12*(ETA1*R1*GR1+ETA2*R2*GR2)
C      B1 = -6.0*(ETA1*R1*R1*GR1*GR1+ETA2*R*R*GR12*GR12)
C      B2 = -6.0*(ETA2*R2*R2*GR2*GR2+ETA1*R*R*GR12*GR12)
C      ALF = 0.5*PI*((DEN1+DEN2)*XIC-(18.0*ETA1*ETA2*(2.0*R+
C     >      R1*R2*(ETA1*R1*R1+ETA2*R2*R2))*(R2-R1)**2)/PI)/
C     >      (XIA*XIA)
C      A1 = ALF*R1**3+(XIC+(1.0+2.0*XI)*(ETA1+ETA2)*R1**3-
C     >     3.0*ETA2*(2.0*R+R1*R2*(2.0*ETA1*R1*R1+ETA2*
C     >     R2*R2))*(R2-R1)**2)/XIB
C      A2 = ALF*R2**3+(XIC+(1.0+2.0*XI)*(ETA1+ETA2)*R2**3-
C     >     3.0*ETA1*(2.0*R+R1*R2*(2.0*ETA2*R2*R2+ETA1*
C     >     R1*R1))*(R2-R1)**2)/XIB
C      D = 0.5*(ETA1*A1+ETA2*A2)
C      AK = 14.399*11604.9/T
C      C = (PI/2.0)/(1.0-(PI/6.0)*(DEN1*R1C+DEN2*R2C))
C      F1 = R1*R2
C      F2 = C*R1*R2*(DEN1*R1S+DEN2*R2S)+R1+R2
C      F3 = C*(DEN1*R1C+DEN2*R2C)+1.0
C      G1 = Z1*(C*DEN2*R2C+1.0)-C*DEN2*R1S*R2*Z2
C      G2 = Z2*(C*DEN1*R1C+1.0)-C*DEN1*R2S*R1*Z1
C      H1 = Z1*R2
C      H2 = Z2*R1
CC
CC     COEFFICIENTS OF POLYNOMIAL FOR GAMMA
CC
C      COEF(1) = F1*F1
C      COEF(2) = 2.0*F1*F2
C      COEF(3) = 2.0*F1*F3+F2*F2
C      COEF(4) = 2.0*F2*F3
C      COEF(5) = F3*F3-AK*PI*(DEN1*H1*H1+DEN2*H2*H2)
C      COEF(6) = -2.0*AK*PI*(DEN1*G1*H1+DEN2*G2*H2)
C      COEF(7) = -AK*PI*(DEN1*G1*G1+DEN2*G2*G2)
CC
C      ACON=0.1
CC      TOL = X02AAF(ACON)
C      NCON=7
C      IFAIL = 0
CC      CALL C02AEF(COEF,NCON,REZ,IMZ,TOL,IFAIL)
CC      IF (IFAIL.NE.0) GO TO 105
CC      DO 1 I=1,6
CC      IF (REZ(I).GT.0.) GAM=REZ(I)
C      CALL ZPOLR(COEF,NCON,COZ,IFAIL)
C      IF (IFAIL.NE.0) GO TO 105
C      DO I =1,6
C         REZ(I)=DREAL(COZ(I))
C         IMZ(I)=DIMAG(COZ(I))
C      ENDDO
C      DO 1 I = 1,6
C         IF(REZ(I).GT.0) GAM=REZ(I)
C    1 CONTINUE
C      DNM = F1*GAM*GAM+F2*GAM+F3
CC      WRITE(*,125)DNM,GAM,F1,F2,F3
CC  125 FORMAT(1X,'DNM GAM F1 F2 F3-- ',5E20.12)C

C      HX1 = (H1*GAM+G1)/DNM
C      HX2 = (H2*GAM+G2)/DNM
C      HN1 = (HX1-Z1)/R1
C      HN2 = (HX2-Z2)/R2
C      HY1 = HN1+GAM*HX1
C      HY2 = HN2+GAM*HX2
C      U1 = AK*(2.0*R1*HY1**2/3.0-2.0*GAM*HX1**2-2.0*R1*HN1**2)
C      U2 = AK*(2.0*R2*HY2**2/3.0-2.0*GAM*HX2**2-2.0*R2*HN2**2)
C      V1 = AK*(2.0*HX1*HY1/R1+HN1**2-HY1**2)
C      V2 = AK*(2.0*HX2*HY2/R2+HN2**2-HY2**2)
C      W1 = AK*HY1**2/(3.0*R1*R1)
C      W2 = AK*HY2**2/(3.0*R2*R2)
C      UP = 2.0*AK*(-Z1*HN2+HX1*HY1-R1*HY1**2/3.0)
C      U = AK*(R1-R2)*((HX1+HX2)*(HY1-HY2)/4.0-(R1-R2)*
C     >    ((HY1+HY2)**2-4.0*HN1*HN2)/16.0)
C      V = -AK*((HX1-HX2)*(HN1-HN2)+(HX1**2+HX2**2)*GAM
C     >     +(R1+R2)*HN1*HN2-(R1*HY1**2+R2*HY2**2)/3.0)
C      W = AK*(HX1*HY1/R1+HX2*HY2/R2+HN1*HN2-0.5*(HY1**2+HY2**2))
C      XP = AK*(HY1**2/(6.0*R1S)+HY2**2/(6.0*R2S))
C      NSEGH = NSEG/2
C      FNORM = XKSEG/(2.0*PI*PI)
CC
CC     CONSTRUCT THE CIJ(K)
CC
C      ROOTN = SQRT(FLOAT(NSEG))
C      DO 2 I=1,NSEG
C      XK = (FLOAT(I)-1.0)*XKSEG
C      IF ((I-1).EQ.0) GO TO 100
C      XK2 = XK*XK
C      XK3 = XK2*XK
C      XK4 = XK3*XK
C      XK5 = XK4*XK
C      XK6 = XK5*XK
C      RK1 = R1*XK
C      RK12 = RK1*RK1
C      RK13 = RK12*RK1
C      RK14 = RK13*RK1
C      RK2 = R2*XK
C      RK22 = RK2*RK2
C      RK23 = RK22*RK2
C      RK24 = RK23*RK2
C      RK = R*XK
C      RKS = RK*RK
C      RK3 = RKS*RK
C      RK4 = RK3*RK
C      SK = S*XK
C      SK2 = SK*SK
C      SK3 = SK2*SK
C      SK4 = SK3*SK
C      COSRK = COS(RK)
C      COSSK = COS(SK)
C      COSRK1 = COS(RK1)
C      COSRK2 = COS(RK2)
C      SINRK = SIN(RK)
C      SINSK = SIN(SK)
C      SINRK1 = SIN(RK1)
C      SINRK2 = SIN(RK2)
C      PA1 = (A1-U1)*(SINRK1-RK1*COSRK1)/XK3
C      PA2 = (A2-U2)*(SINRK2-RK2*COSRK2)/XK3
C      PB1 = (B1-V1)*((2.0-RK12)*COSRK1+2.0*RK1*SINRK1-2.0)/XK4
C      PB2 = (B2-V2)*((2.0-RK22)*COSRK2+2.0*RK2*SINRK2-2.0)/XK4
C      PD1 = (D-W1)*((12.0*RK12-RK14-24.0)*COSRK1+(4.0*RK13-
C     >      24.0*RK1)*SINRK1+24.0)/XK6
C      PD2 = (D-W2)*((12.0*RK22-RK24-24.0)*COSRK2+(4.0*RK23-
C     >      24.0*RK2)*SINRK2+24.0)/XK6
C      QA = (A1*(SINRK-RK*COSRK)+UP*(SINSK-SK*COSSK))/XK3
C     >     +((B*S2-3.0*D*S4-U)*(COSSK-COSRK))/XK2
C      QB = (8.0*D*S3-2.0*B*S-V)*(SK*COSSK-RK*COSRK-SINSK+SINRK)/
C     >     XK3
C      QC = (B-6.0*D*S2-W)*((SK2-2.0)*COSSK-(RKS-2.0)*COSRK+
C     >     2.0*RK*SINRK-2.0*SK*SINSK)/XK4
C      QD = (D-XP)*((SK4-12.0*SK2+24.0)*COSSK-(RK4-12.0*RKS+
C     >     24.0)*COSRK+(4.0*RK3-24.0*RK)*SINRK-(4.0*SK3-
C     >     24.0*SK)*SINSK)/XK6
C      C11 = -PI4*(PA1+PB1+PD1+AK*Z1*Z1*COSRK1/XK2)
C      C22 = -PI4*(PA2+PB2+PD2+AK*Z2*Z2*COSRK2/XK2)
C      C12 = -PI4*(QA+QB+QC+QD+AK*Z1*Z2*COSRK/XK2)
CC
CC     CONSTRUCT THE XIJ(K)
CC
C      DENOM = (1.0-DEN1*C11)*(1.0-DEN2*C22)-DEN1*DEN2*
C     >        C12*C12
C      X1(I) = (DEN1*C11*C11*(1.0-DEN2*C22)+DEN2*C12*C12
C     >         *(1.0+DEN1*C11))*XK/DENOM
C      X2(I) = (DEN2*C22*C22*(1.0-DEN1*C11)+DEN1*C12*C12
C     >         *(1.0+DEN2*C22))*XK/DENOM
C      X3(I) = XK*(C12/DENOM-C12)
C      FUNC = XK*PI4*AK*(1.0/XK2-1.0/(XK2+1.0/(R*R)))
C      X1(I) = ROOTN*(X1(I)-FUNC*Z1*Z1)
C      X2(I) = ROOTN*(X2(I)-FUNC*Z2*Z2)
C      X3(I) = ROOTN*(X3(I)-FUNC*Z1*Z2)
C      GO TO 101
C  100 X1(I) = 0.0
C      X2(I) = 0.0
C      X3(I) = 0.0
C  101 Y1(I) = 0.0
C      Y2(I) = 0.0
C      Y3(I) = 0.0
C    2 CONTINUE
CC
CC     FOURIER TRANSFORM
CC
C      NSL1=NSEG
C      IF1=0
C      CALL C06GCF(Y1,NSL1,IF1)
C      IF2=0
C      CALL C06FCF(X1,Y1,NSL1,IF2)
C      IF3=0
C      CALL C06GCF(Y1,NSL1,IF3)
C      IF1=0
C      CALL C06GCF(Y2,NSL1,IF1)
C      IF2=0
C      CALL C06FCF(X2,Y2,NSL1,IF2)
C      IF3=0
C      CALL C06GCF(Y2,NSL1,IF3)
C      IF1=0
C      CALL C06GCF(Y3,NSL1,IF1)
C      IF2=0
C      CALL C06FCF(X3,Y3,NSL1,IF2)
C      IF3=0
C      CALL C06GCF(Y3,NSL1,IF3)
CC
CC     CONSTRUCT AND LIST XIJ(R)
CC
C      X1(1) = -1.0+A1-U1
C      X2(1) = -1.0+A2-U2
C      X3(1) = -1.0+A1+UP
C      DO 3 I=2,NSEG
C      IF(I.GT.NSEGH) GO TO 102
C C     XX = (FLOAT(I)-1.0)*XXSEG
C      X1(I) = Y1(I)*FNORM/XX
C      X2(I) = Y2(I)*FNORM/XX
C      X3(I) = Y3(I)*FNORM/XX
C      FUNK = AK*(1.0-EXP(-XX/R))/XX
C      X1(I) = X1(I)+FUNK*Z1*Z1
C      X2(I) = X2(I)+FUNK*Z2*Z2
C      X3(I) = X3(I)+FUNK*Z1*Z2
C      GO TO 103
C  102 X1(I) = 0.0
C      X2(I) = 0.0
C      X3(I) = 0.0
C  103 CONTINUE
C    3 CONTINUE
C      IF (NHS.LT.1) GO TO 104
C  104 CONTINUE
      RETURN
C  105 CONTINUE
C     STOP
      END
C
C
C
C
      SUBROUTINE COARSE(NDIM,NBAS,QBAS,X)
      IMPLICIT REAL*8(A-H,O-Z)
C      PARAMETER(MX=4096)
      PARAMETER(MX=1024)
      COMMON/CRS/CBAS(10)
      DIMENSION QBAS(10,100),NBAS(10),X(MX)
C
      LMAX = NBAS(NDIM)
      DO 1 I=1,NDIM
      CBAS(I) = 0.0
      DO 1 L=1,LMAX
      CBAS(I) = CBAS(I)+QBAS(I,L)*X(L)
    1 CONTINUE
      RETURN
      END
C
C
C
C
      SUBROUTINE FINE(NDIM,NBAS,CBAS,PBAS,X)
      IMPLICIT REAL*8(A-H,O-Z)
C      PARAMETER(MX=4096,MXH=2048)
      PARAMETER(MX=1024,MXH=512)
      COMMON/SEG/XXSEG,XKSEG,NSEG
      COMMON/FIN/NPRINT,NREM,Y(MX),DBAS(10)
      COMMON/AJS05/QBAS(10,100)
      DIMENSION NBAS(10),CBAS(10),PBAS(10,100),X(MXH)
C
      LMAX = NBAS(NDIM)
      LMAXP = LMAX+1
      DO 1 I=LMAXP,NSEG
      Y(I) = X(I)
    1 CONTINUE
      J1 = 1
      IF (NDIM.GT.1) J1=NBAS(NDIM-1)
      J2 = NBAS(NDIM)
      DSEG = J2-J1
      DO 2 J=J1,J2
      XL = 1.0-(FLOAT(J)-FLOAT(J1))/DSEG
      Y(J) = X(J)-CBAS(NDIM)*XL
    2 CONTINUE
      IMAX = NDIM-1
      J2 = 1
      DO 4 I=1,IMAX
      J1 = J2
      J2 = NBAS(I)
      DSEG = J2-J1
      J2P = J2-1
      DO 3 J=J1,J2P
      XL = 1.0-(FLOAT(J)-FLOAT(J1))/DSEG
      XR = 1.0-XL
      Y(J) = X(J)-CBAS(I)*XL-CBAS(I+1)*XR
    3 CONTINUE
    4 CONTINUE
C
C     CHECK THAT FINE REMAINDER IS ORTHOGONAL TO COARSE
C     SUBSPACE
C
      DO 5 I=1,NDIM
      DBAS(I) = 0.0
      DO 5 L=1,LMAX
      DBAS(I) = DBAS(I)+PBAS(I,L)*Y(L)
    5 CONTINUE
      RETURN
      END
C
C
C
C
      SUBROUTINE SOLVE
      IMPLICIT REAL*8(A-H,O-Z)
      COMMON/ND/NDIM1,NDIM2,NDIM3
      COMMON/DB/DBAS1(10),DBAS2(10),DBAS3(10)
      COMMON/CB/CBAS1(10),CBAS2(10),CBAS3(10)
      COMMON/AJ/AJIN11(10,10),AJIN12(10,10),AJIN13(10,10)
      COMMON/AJ/AJIN21(10,10),AJIN22(10,10),AJIN23(10,10)
      COMMON/AJ/AJIN31(10,10),AJIN32(10,10),AJIN33(10,10)
      COMMON/NR/STEP,ACC,NRIT
      COMMON/ID/IEND
      COMMON/AJS06/DCBAS1(10),DCBAS2(10),DCBAS3(10)
C
      NCALL = 0
      STEP2 = STEP**2
  100 CALL CALFUN
      IF (IEND.EQ.1) GOTO 133
      NCALL = NCALL+1
      DISCR1 = 0.0
      DISCR2 = 0.0
      DISCR3 = 0.0
      DO 1 I=1,NDIM1
      DISCR1 = DISCR1+DBAS1(I)**2
    1 CONTINUE
      DO 2 I=1,NDIM2
      DISCR2 = DISCR2+DBAS2(I)**2
    2 CONTINUE
      DO 3 I=1,NDIM3
      DISCR3 = DISCR3+DBAS3(I)**2
    3 CONTINUE
      IF (DISCR1-ACC) 107,107,109
  107 IF (DISCR2-ACC) 108,108,109
  108 IF (DISCR3-ACC) 133,133,109
  109 IF (NCALL.GT.NRIT) GO TO 132
C
C     CALCULATE NEW N-R ESTIMATE OF CBAS
C
      DD1 = 0.0
      DD2 = 0.0
      DD3 = 0.0
      DO 8 I=1,NDIM1
      DCBAS1(I) = 0.0
      DO 5 J=1,NDIM1
      DCBAS1(I) = DCBAS1(I)-AJIN11(I,J)*DBAS1(J)
    5 CONTINUE
      DO 6 J=1,NDIM2
      DCBAS1(I) = DCBAS1(I)-AJIN12(I,J)*DBAS2(J)
    6 CONTINUE
      DO 7 J=1,NDIM3
      DCBAS1(I) = DCBAS1(I)-AJIN13(I,J)*DBAS3(J)
    7 CONTINUE
      DD1 = DD1+DCBAS1(I)**2
    8 CONTINUE
      DO 12 I=1,NDIM2
      DCBAS2(I) = 0.0
      DO 9 J=1,NDIM1
      DCBAS2(I) = DCBAS2(I)-AJIN21(I,J)*DBAS1(J)
    9 CONTINUE
      DO 10 J=1,NDIM2
      DCBAS2(I) = DCBAS2(I)-AJIN22(I,J)*DBAS2(J)
   10 CONTINUE
      DO 11 J=1,NDIM3
      DCBAS2(I) = DCBAS2(I)-AJIN23(I,J)*DBAS3(J)
   11 CONTINUE
      DD2 = DD2+DCBAS2(I)**2
   12 CONTINUE
      DO 16 I=1,NDIM3
      DCBAS3(I) = 0.0
      DO 13 J=1,NDIM1
      DCBAS3(I) = DCBAS3(I)-AJIN31(I,J)*DBAS1(J)
   13 CONTINUE
      DO 14 J=1,NDIM2
      DCBAS3(I) = DCBAS3(I)-AJIN32(I,J)*DBAS2(J)
   14 CONTINUE
      DO 15 J=1,NDIM3
      DCBAS3(I) = DCBAS3(I)-AJIN33(I,J)*DBAS3(J)
   15 CONTINUE
      DD3 = DD3+DCBAS3(I)**2
   16 CONTINUE
      IF (STEP2-DD1) 122,123,123
  122 SCALE = SQRT(STEP2/DD1)
      DO 17 I=1,NDIM1
      DCBAS1(I) = DCBAS1(I)*SCALE
   17 CONTINUE
  123 IF (STEP2-DD2) 124,125,125
  124 SCALE = SQRT(STEP2/DD2)
      DO 18 I=1,NDIM2
      DCBAS2(I) = DCBAS2(I)*SCALE
   18 CONTINUE
  125 IF (STEP2-DD3) 126,127,127
  126 SCALE = SQRT(STEP2/DD3)
      DO 19 I=1,NDIM3
      DCBAS3(I) = DCBAS3(I)*SCALE
   19 CONTINUE
  127 CONTINUE
      DO 20 I=1,NDIM1
      CBAS1(I) = CBAS1(I)+DCBAS1(I)
   20 CONTINUE
      DO 21 I=1,NDIM2
      CBAS2(I) = CBAS2(I)+DCBAS2(I)
   21 CONTINUE
      DO 22 I=1,NDIM3
      CBAS3(I) = CBAS3(I)+DCBAS3(I)
   22 CONTINUE
      GO TO 100
  132 CONTINUE
  133 CONTINUE
C        TYPE*,NCALL,' CALFUNS'
        WRITE(*,*)NCALL,'CALFUNS'
      RETURN
      END
C
C
C
C
      SUBROUTINE DCF(NDIM,NBAS,CBAS,POT,Y,MODE,ZA,ZB,T)
      IMPLICIT REAL*8(A-H,O-Z)
C      PARAMETER(MX=4096,MXH=2048)
      PARAMETER(MX=1024,MXH=512)
      COMMON/SEG/XXSEG,XKSEG,NSEG
      COMMON/RR/R1,R2
      COMMON/CIJ/B(MX),C(MX),EXPO(MXH)
      COMMON/AJS07/A(MX),WORK(MX)
      DIMENSION NBAS(10),CBAS(10),POT(MX),Y(MX)
C
      NSEGH = NSEG/2
      NSEGHP = NSEGH+1
      XMODE = MODE-1
      R = (R1+R2)/2.0
      AK = 14.399*11604.9/T
C
C     USE COEFFICIENTS CBAS AND FINE REMAINDER Y TO
C     CONSTRUCT FULL H-C
C
      DO 1 I=1,NSEG
      C(I) = Y(I)
      B(I) = 0.0
    1 CONTINUE
      J1 = 1
      IF (NDIM.GT.1) J1=NBAS(NDIM-1)
      J2 = NBAS(NDIM)
      DSEG = J2-J1
      DO 2 J=J1,J2
      XL = 1.0-(FLOAT(J)-FLOAT(J1))/DSEG
      C(J) = C(J)+CBAS(NDIM)*XL
    2 CONTINUE
      IMAX = NDIM-1
      J2 = 1
      DO 4 I=1,IMAX
      J1 = J2
      J2 = NBAS(I)
      DSEG = J2-J1
      J2P = J2-1
      DO 3 J=J1,J2P
      XL = 1.0-(FLOAT(J)-FLOAT(J1))/DSEG
      XR = 1.0-XL
      C(J) = C(J)+CBAS(I)*XL+CBAS(I+1)*XR
    3 CONTINUE
    4 CONTINUE
  100 CONTINUE
C
C     USE HNC OR PY EQUATION TO CALCULATE DCF
C
      A(1) = 0.0
      EXPO(1) = -1.0
      ROOTN = SQRT(FLOAT(NSEG))
      DO 5 I=2,NSEGH
      XX = (FLOAT(I)-1.0)*XXSEG
      ARG = XMODE*C(I)-POT(I)
      IF (ARG.LT.-30.) GO TO 101
      EXPON = EXP(ARG)
      GO TO 102
  101 EXPON = 0.0
  102 GO TO (103,104),MODE
  103 A(I) = (1.0+C(I))*(EXPON-1.0)*XX
      GO TO 105
  104 A(I) = (EXPON-C(I)-1.0)*XX
  105 EXPO(I) = EXPON-1.0
      F = AK*(1.0-EXP(-XX/R))
      A(I) = ROOTN*(A(I)+F*ZA*ZB)
    5 CONTINUE
      DO 6 I=NSEGHP,NSEG
      A(I) = 0.0
    6 CONTINUE
C
C     FOURIER TRANSFORM X TO K
C
      NSL1=NSEG
      IF1=0
      CALL C06GCF(B,NSL1,IF1)
      IF2=0
      CALL C06FCF(A,B,NSL1,IF2)
      IF3=0
      CALL C06GCF(B,NSL1,IF3)
      RETURN
      END
C
C
C
C
      SUBROUTINE JACOB(NDIMA,NDIMB,NBASA,NBASB,PBAS,QBAS,
     >                 EXPO,E,D,DEL)
      IMPLICIT REAL*8(A-H,O-Z)
C      PARAMETER(MX=4096,MXH=2048)
      PARAMETER(MX=1024,MXH=512)
      COMMON/SEG/XXSEG,XKSEG,NSEG
      COMMON/JAC/AJAC(10,10),NJAC
      COMMON/AJS08/FUNDER(100,100)
      DIMENSION NBASA(10),NBASB(10),PBAS(10,100),QBAS(10,100)
      DIMENSION E(MX),D(MX),EXPO(MXH)
C
      PI = 3.14159265
      FNORM1 = XXSEG/PI
      FNORM2 = 2.0*FNORM1
      NSEGH = NSEG/2
      LMAXA = MIN0(NSEGH,NBASA(NDIMA))
      LMAXB = MIN0(NSEGH,NBASB(NDIMB))
C
      DO 1 J=1,LMAXB
      RJ = (FLOAT(J)-1.0)*XXSEG
      FUNDER(1,J) = FNORM2*RJ*EXPO(J)*E(J)
      DO 1 I=2,LMAXA
      I1 = IABS(I-J)+1
      I2 = IABS(I+J)-1
      XX = (FLOAT(I)-1.0)*XXSEG
      FUNDER(I,J) = FNORM1*RJ*EXPO(J)*(D(I1)-D(I2))/XX
    1 CONTINUE
      DO 2 I=1,NDIMA
      DO 2 J=1,NDIMB
      AJAC(I,J) = 0.0
      DO 2 K=1,LMAXA
      DO 2 L=1,LMAXB
      AJAC(I,J) = AJAC(I,J)-QBAS(I,K)*FUNDER(K,L)*PBAS(J,L)
    2 CONTINUE
      IF (DEL.LT.1.D0) GO TO 100
      DO 3 I=1,NDIMA
      AJAC(I,I) = AJAC(I,I)+DEL
    3 CONTINUE
  100 CONTINUE
  101 CONTINUE
      RETURN
      END
C
C
C
C
      SUBROUTINE DISC(NDIM,ABAS,DBAS,C,X)
      IMPLICIT REAL*8(A-H,O-Z)
C      PARAMETER(MX=4096)
      PARAMETER(MX=1024)
      COMMON/SEG/XXSEG,XKSEG,NSEG
      COMMON/D/DTOT
      DIMENSION ABAS(10,10),DBAS(10),C(MX),X(MX)
C
      NSEGH = NSEG/2
      DO 1 I=1,NSEGH
      DI = C(I)-X(I)
      DTOT = DTOT+DI*DI
    1 CONTINUE
      DCSE = 0.0
      DO 2 I=1,NDIM
      DCSE = DCSE+ABAS(I,I)*DBAS(I)**2
    2 CONTINUE
      DO 3 I=2,NDIM
      DCSE = DCSE+2.0*ABAS(I,I-1)*DBAS(I)*DBAS(I-1)
    3 CONTINUE
  100 DTOT = DTOT*XXSEG
      DCSE = DCSE*XXSEG
      RETURN
      END
C
C
C
C
      SUBROUTINE FINAL(X,POT,MODE,NX,PI)
      IMPLICIT REAL*8(A-H,O-Z)
C      PARAMETER(MX=4096)
      PARAMETER(MX=1024)
      COMMON/SEG/XXSEG,XKSEG,NSEG
      COMMON/HRK/HR(MX),GR(MX),HK(MX)
      COMMON/BXW/BX(MX),BWORK(MX),BD(2,MX),DD(2)
      COMMON/SNO/CK(MX),CR(MX)
      COMMON/ZT/Z1,Z2,T,ZREAL
      COMMON/BH/ETA,DENS
      DIMENSION X(MX),POT(MX)
      DIMENSION YF(2048)
C
      NSEGH = NSEG/2
      I = 1
      XX = 0.0
      C0 = -X(1)-1.0
      G0 = 0.0
      HR(1)=X(1)+C0
      GR(1)=G0
      DO 1 I=2,NSEGH
      XX = (FLOAT(I)-1.0)*XXSEG
      GO TO (100,101),MODE
  100 ARG = -POT(I)
      GO TO 102
  101 ARG = X(I)-POT(I)
  102 IF (ARG.LT.-50.0) GO TO 103
      EXPON = EXP(ARG)
      GO TO 104
  103 EXPON = 0.0
  104 GO TO (105,106),MODE
  105 CI = (1.0+X(I))*(EXPON-1.0)
      GO TO 107
  106 CI = EXPON-X(I)-1.0
  107 GI = X(I)+CI+1.0

      HR(I)=X(I)+CI
      GR(I)=GI
      CR(I)=CI

    1 CONTINUE


      CALL FOURIE(PI,HR,HK,NX,XXSEG,0,BX,YF,BWORK)

      CALL FOURIE(PI,CR,CK,NX,XXSEG,0,BX,YF,BWORK)
C      DO 50 JK = 1,200
C      Q = XKSEG*FLOAT(JK-1)
C      SQ = 1.0/(1.0-DENS*CK(JK))
C   50 WRITE(60,*)Q,SQ
C      WRITE(60,*)T,ETA,DENS
C      CLOSE(60)
      RETURN
      END
C
C
C
C
      SUBROUTINE CALFUN
      IMPLICIT REAL*8(A-H,O-Z)
C      PARAMETER(MX=4096,MXH=2048)
      PARAMETER(MX=1024,MXH=512)
      COMMON/SEG/XXSEG,XKSEG,NSL2
      COMMON/ND/NDIM1,NDIM2,NDIM3
      COMMON/NB2/NBAS1(10),NBAS2(10),NBAS3(10)
      COMMON/AB/ABAS1(10,10),ABAS2(10,10),ABAS3(10,10)
      COMMON/BB/BBAS1(10,10),BBAS2(10,10),BBAS3(10,10)
      COMMON/CB/CBAS1(10),CBAS2(10),CBAS3(10)
      COMMON/DB/DBAS1(10),DBAS2(10),DBAS3(10)
      COMMON/PB/PBAS1(10,100),PBAS2(10,100),PBAS3(10,100)
      COMMON/QB/QBAS1(10,100),QBAS2(10,100),QBAS3(10,100)
      COMMON/X/X1(MX),X2(MX),X3(MX)
      COMMON/Y/Y1(MX),Y2(MX),Y3(MX)
      COMMON/POT/VPOT1(MX),VPOT2(MX),VPOT3(MX)
      COMMON/AJ/AJIN11(10,10),AJIN12(10,10),AJIN13(10,10)
      COMMON/AJ/AJIN21(10,10),AJIN22(10,10),AJIN23(10,10)
      COMMON/AJ/AJIN31(10,10),AJIN32(10,10),AJIN33(10,10)
      COMMON/JAC/AJAC(10,10),NJAC
      COMMON/CIJ/B(MX),C(MX),EXPO(MXH)
      COMMON/D/DTOT
      COMMON/ID/IEND
      COMMON/DEN/DEN1,DEN2
      COMMON/COUNT/NCNT,MODE,ACCTOT
      COMMON/ZT/Z1,Z2,T,ZREAL
      COMMON/RR/R1,R2
      COMMON/JCON/AJC
      COMMON/AJS12/A11(MX),A12(MX),A13(MX)
      COMMON/AJS13/A21(MX),A22(MX),A23(MX)
      COMMON/AJS14/A31(MX),A32(MX),A33(MX)
      COMMON/AJS15/B11(MX),B12(MX),B13(MX)
      COMMON/AJS16/B21(MX),B22(MX),B23(MX)
      COMMON/AJS17/B31(MX),B32(MX),B33(MX)
      COMMON/AJS18/C1(MX),C2(MX),C3(MX)
      COMMON/AJS19/D11(MX),D12(MX),D13(MX)
      COMMON/AJS20/D21(MX),D22(MX),D23(MX)
      COMMON/AJS21/D31(MX),D32(MX),D33(MX)
      COMMON/AJS22/E11(MX),E12(MX),E13(MX)
      COMMON/AJS23/E21(MX),E22(MX),E23(MX)
      COMMON/AJS24/E31(MX),E32(MX),E33(MX)
      COMMON/AJS25/EXPO1(MXH),EXPO2(MXH),EXPO3(MXH)
      COMMON/AJS26/AJINT(30,30),UNIT(30,30),SOLN(30,30)
      COMMON/AJS27/CROUT(30,30),RESID(30,30),WORK(30,30)
      COMMON/AJS28/WORK2(MX)
      DIMENSION WKAREA (990)
C
      IFUN = 100
      IF (NBAS1(NDIM1).GT.IFUN) GO TO 139
      IF (NBAS2(NDIM2).GT.IFUN) GO TO 139
      IF (NBAS3(NDIM3).GT.IFUN) GO TO 139
C
C     COUNT CALLS OF CALFUN
C
      NCNT = NCNT+1
C
C     CONSTANTS
C
      PI = 3.14159265
      PI4 = 4.0*PI
      NSEGH = NSL2/2
      NSEGHP = NSEGH+1
      NSEGHQ = NSEGHP+1
      NSEG2 = NSL2+2
      XKSEGQ = 0.25*XKSEG
      FXNORM = PI4*XXSEG
      FKNORM = XKSEG/(8.0*PI*PI)
      R = (R1+R2)/2.0
      AK = 14.399*11604.9/T
      LMAX1 = MIN0(NSEGH,NBAS1(NDIM1))
      LMAX2 = MIN0(NSEGH,NBAS2(NDIM2))
      LMAX3 = MIN0(NSEGH,NBAS3(NDIM3))
C
C     CONSTRUCT XIJ(K) AND QUANTITIES NEEDED FOR
C     JACOBIAN MATRICES
C
      CALL DCF(NDIM1,NBAS1,CBAS1,VPOT1,Y1,MODE,Z1,Z1,T)
      DO 1 I=1,NSL2
      B11(I) = B(I)

      C1(I) = C(I)
      B22(I)=B(I)
      B33(I)=B(I)
      C2(I)=C(I)
      C3(I)=C(I)
    1 CONTINUE
      DO 2 I=1,NSEGH
      EXPO1(I) = EXPO(I)
      EXPO2(I)=EXPO(I)
      EXPO3(I)=EXPO(I)
    2 CONTINUE
      B11(1) = 0.0
      B12(1) = 0.0
      B13(1) = 0.0
      B21(1) = 0.0
      B22(1) = 0.0
      B23(1) = 0.0
      B31(1) = 0.0
      B32(1) = 0.0
      B33(1) = 0.0
      A11(1) = 0.0
      A12(1) = 0.0
      A13(1) = 0.0
      A21(1) = 0.0
      A22(1) = 0.0
      A23(1) = 0.0
      A31(1) = 0.0
      A32(1) = 0.0
      A33(1) = 0.0
      X01 = 0.0
      X02 = 0.0
      X03 = 0.0
      DO 7 I=2,NSEGH
      XK = (FLOAT(I)-1.0)*XKSEG
      XK2 = XK*XK
      FUNK = PI4*AK*(1.0/XK2-1.0/(XK2+1.0/(R*R)))
      IP = NSEG2-I
      CC1 = FXNORM*B11(I)/XK-FUNK*Z1*Z1
      CC2 = FXNORM*B22(I)/XK-FUNK*Z2*Z2
      CC3 = FXNORM*B33(I)/XK-FUNK*Z1*Z2
      DENOM = (1.0-DEN1*CC1)*(1.0-DEN2*CC2)-DEN1*DEN2*CC3*CC3
      DENOM2 = DENOM*DENOM
      ALF1 = DEN1*CC1*CC1*(1.0-DEN2*CC2)+DEN2*CC3*CC3*
     >       (1.0+DEN1*CC1)
      ALF2 = DEN2*CC2*CC2*(1.0-DEN1*CC1)+DEN1*CC3*CC3*
     >       (1.0+DEN2*CC2)
      BET1 = DEN1*(1.0-DEN2*CC2)
      BET2 = DEN2*(1.0-DEN1*CC1)
      BET3 = 2.0*DEN1*DEN2*CC3
      GAM1 = 2.0*CC1*BET1+DEN1*DEN2*CC3*CC3
      GAM2 = 2.0*CC2*BET2+DEN1*DEN2*CC3*CC3
      GAM3 = -DEN1*DEN2*CC1*CC1
      GAM4 = -DEN1*DEN2*CC2*CC2
      GAM5 = 2.0*DEN2*CC3*(1.0+DEN1*CC1)
      GAM6 = 2.0*DEN1*CC3*(1.0+DEN2*CC2)
      SS1 = (1.0-DEN2*CC2)/DENOM
      SS2 = (1.0-DEN1*CC1)/DENOM
C
C      IF (SS1) 139,139,109
C  109 IF (SS2) 139,139,110
  109 CONTINUE
  110 EL11 = XK*(ALF1/DENOM-FUNK*Z1*Z1)
      EL12 = XK*(ALF2/DENOM-FUNK*Z2*Z2)
      EL13 = XK*((CC3/DENOM-CC3)-FUNK*Z1*Z2)
      EL21 = GAM1/DENOM+BET1*ALF1/DENOM2
      EL22 = GAM2/DENOM+BET2*ALF2/DENOM2
      EL23 = 1.0/DENOM+BET3*CC3/DENOM2-1.0
      ROOTN = SQRT(FLOAT(NSL2))
      A11(I) = ROOTN*(EL11+EL21)
      A12(I) = ROOTN*(GAM3/DENOM+BET2*ALF1/DENOM2)
      A13(I) = ROOTN*(GAM5/DENOM+BET3*ALF1/DENOM2)
      A21(I) = ROOTN*(GAM4/DENOM+BET1*ALF2/DENOM2)
      A22(I) = ROOTN*(EL12+EL22)
      A23(I) = ROOTN*(GAM6/DENOM+BET3*ALF2/DENOM2)
      A31(I) = ROOTN*BET1*CC3/DENOM2
      A32(I) = ROOTN*BET2*CC3/DENOM2
      A33(I) = ROOTN*(EL13+EL23)
      A11(IP) = ROOTN*(-EL11+EL21)
      A12(IP) = A12(I)
      A13(IP) = A13(I)
      A21(IP) = A21(I)
      A22(IP) = ROOTN*(-EL12+EL22)
      A23(IP) = A23(I)
      A31(IP) = A31(I)
      A32(IP) = A32(I)
      A33(IP) = ROOTN*(-EL13+EL23)
      B11(I) = XK*ROOTN*EL21
      B12(I) = XK*A12(I)
      B13(I) = XK*A13(I)
      B21(I) = XK*A21(I)
      B22(I) = XK*ROOTN*EL22
      B23(I) = XK*A23(I)
      B31(I) = XK*A31(I)
      B32(I) = XK*A32(I)
      B33(I) = XK*ROOTN*EL23
      B11(IP) = -B11(I)
      B12(IP) = -B12(I)
      B13(IP) = -B13(I)
      B21(IP) = -B21(I)
      B22(IP) = -B22(I)
      B23(IP) = -B23(I)
      B31(IP) = -B31(I)
      B32(IP) = -B32(I)
      B33(IP) = -B33(I)
      X01 = X01+EL11*XK
      X02 = X02+EL12*XK
      X03 = X03+EL13*XK
    7 CONTINUE
      A11(NSEGHP) = 0.5*(A11(NSEGH)+A11(NSEGHQ))
      A12(NSEGHP) = 0.5*(A12(NSEGH)+A12(NSEGHQ))
      A13(NSEGHP) = 0.5*(A13(NSEGH)+A13(NSEGHQ))
      A21(NSEGHP) = 0.5*(A21(NSEGH)+A21(NSEGHQ))
      A22(NSEGHP) = 0.5*(A22(NSEGH)+A22(NSEGHQ))
      A23(NSEGHP) = 0.5*(A23(NSEGH)+A23(NSEGHQ))
      A31(NSEGHP) = 0.5*(A31(NSEGH)+A31(NSEGHQ))
      A32(NSEGHP) = 0.5*(A32(NSEGH)+A32(NSEGHQ))
      A33(NSEGHP) = 0.5*(A33(NSEGH)+A33(NSEGHQ))
      B11(NSEGHP) = 0.0
      B12(NSEGHP) = 0.0
      B13(NSEGHP) = 0.0
      B21(NSEGHP) = 0.0
      B22(NSEGHP) = 0.0
      B23(NSEGHP) = 0.0
      B31(NSEGHP) = 0.0
      B32(NSEGHP) = 0.0
      B33(NSEGHP) = 0.0
C
C     FOURIER TRANSFORM K TO X
C
      NSEG = NSL2
      IF1=0
      CALL C06GCF(B11,NSEG,IF1)
      IF2=0
      CALL C06FCF(A11,B11,NSEG,IF2)
      IF3=0
      CALL C06GCF(B11,NSEG,IF3)
      IF1=0
      CALL C06GCF(B12,NSEG,IF1)
      IF2=0
      CALL C06FCF(A12,B12,NSEG,IF2)
      IF3=0
      CALL C06GCF(B12,NSEG,IF3)
      IF1=0
      CALL C06GCF(B13,NSEG,IF1)
      IF2=0
      CALL C06FCF(A13,B13,NSEG,IF2)
      IF3=0
      CALL C06GCF(B13,NSEG,IF3)
      IF1=0
      CALL C06GCF(B21,NSEG,IF1)
      IF2=0
      CALL C06FCF(A21,B21,NSEG,IF2)
      IF3=0
      CALL C06GCF(B21,NSEG,IF3)
      IF1=0
      CALL C06GCF(B22,NSEG,IF1)
      IF2=0
      CALL C06FCF(A22,B22,NSEG,IF2)
      IF3=0
      CALL C06GCF(B22,NSEG,IF3)
      IF1=0
      CALL C06GCF(B23,NSEG,IF1)
      IF2=0
      CALL C06FCF(A23,B23,NSEG,IF2)
      IF3=0
      CALL C06GCF(B23,NSEG,IF3)
      IF1=0
      CALL C06GCF(B31,NSEG,IF1)
      IF2=0
      CALL C06FCF(A31,B31,NSEG,IF2)
      IF3=0
      CALL C06GCF(B31,NSEG,IF3)
      IF1=0
      CALL C06GCF(B32,NSEG,IF1)
      IF2=0
      CALL C06FCF(A32,B32,NSEG,IF2)
      IF3=0
      CALL C06GCF(B32,NSEG,IF3)
      IF1=0
      CALL C06GCF(B33,NSEG,IF1)
      IF2=0
      CALL C06FCF(A33,B33,NSEG,IF2)
      IF3=0
      CALL C06GCF(B33,NSEG,IF3)
      X1(1) = 4.0*FKNORM*X01+AK*Z1*Z1/R
      X2(1) = 4.0*FKNORM*X02+AK*Z2*Z2/R
      X3(1) = 4.0*FKNORM*X03+AK*Z1*Z2/R
      ZERO=0.00010
      FUNC=0.0
      DO 8 I=2,NSEGH
      XX = (FLOAT(I)-1.0)*XXSEG
      IP = NSEG2-I
      IF(Z1.LT.ZERO.AND.Z2.LT.ZERO)GO TO 567
      FUNC = AK*(1.0-EXP(-XX/R))/XX
  567 CONTINUE
      X1(I) = FKNORM*(B11(I)-B11(IP))/XX+FUNC*Z1*Z1
      X2(I) = FKNORM*(B22(I)-B22(IP))/XX+FUNC*Z2*Z2
      X3(I) = FKNORM*(B33(I)-B33(IP))/XX+FUNC*Z1*Z2
    8 CONTINUE
      DO 9 I=NSEGHP,NSL2
      X1(I) = 0.0
      X2(I) = 0.0
      X3(I) = 0.0
    9 CONTINUE
      D11(1) = 2.0*XKSEGQ*A11(1)
      D12(1) = 2.0*XKSEGQ*A12(1)
      D13(1) = 2.0*XKSEGQ*A13(1)
      D21(1) = 2.0*XKSEGQ*A21(1)
      D22(1) = 2.0*XKSEGQ*A22(1)
      D23(1) = 2.0*XKSEGQ*A23(1)
      D31(1) = 2.0*XKSEGQ*A31(1)
      D32(1) = 2.0*XKSEGQ*A32(1)
      D33(1) = 2.0*XKSEGQ*A33(1)
      E11(1) = 0.0
      E12(1) = 0.0
      E13(1) = 0.0
      E21(1) = 0.0
      E22(1) = 0.0
      E23(1) = 0.0
      E31(1) = 0.0
      E32(1) = 0.0
      E33(1) = 0.0
      DO 10 I=2,NSEGH
      IP = NSEG2-I
      D11(I) = XKSEGQ*(A11(I)+A11(IP))
      D12(I) = XKSEGQ*(A12(I)+A12(IP))
      D13(I) = XKSEGQ*(A13(I)+A13(IP))
      D21(I) = XKSEGQ*(A21(I)+A21(IP))
      D22(I) = XKSEGQ*(A22(I)+A22(IP))
      D23(I) = XKSEGQ*(A23(I)+A23(IP))
      D31(I) = XKSEGQ*(A31(I)+A31(IP))
      D32(I) = XKSEGQ*(A32(I)+A32(IP))
      D33(I) = XKSEGQ*(A33(I)+A33(IP))
      E11(I) = XKSEGQ*(-A11(I)+A11(IP))
      E12(I) = XKSEGQ*(-A12(I)+A12(IP))
      E13(I) = XKSEGQ*(-A13(I)+A13(IP))
      E21(I) = XKSEGQ*(-A21(I)+A21(IP))
      E22(I) = XKSEGQ*(-A22(I)+A22(IP))
      E23(I) = XKSEGQ*(-A23(I)+A23(IP))
      E31(I) = XKSEGQ*(-A31(I)+A31(IP))
      E32(I) = XKSEGQ*(-A32(I)+A32(IP))
      E33(I) = XKSEGQ*(-A33(I)+A33(IP))
      D11(IP) = D11(I)
      D12(IP) = D12(I)
      D13(IP) = D13(I)
      D21(IP) = D21(I)
      D22(IP) = D22(I)
      D23(IP) = D23(I)
      D31(IP) = D31(I)
      D32(IP) = D32(I)
      D33(IP) = D33(I)
      E11(IP) = -E11(I)
      E12(IP) = -E12(I)
      E13(IP) = -E13(I)
      E21(IP) = -E21(I)
      E22(IP) = -E22(I)
      E23(IP) = -E23(I)
      E31(IP) = -E31(I)
      E32(IP) = -E32(I)
      E33(IP) = -E33(I)
   10 CONTINUE
      D11(NSEGHP) = 0.5*(D11(NSEGH)+D11(NSEGHQ))
      D12(NSEGHP) = 0.5*(D12(NSEGH)+D12(NSEGHQ))
      D13(NSEGHP) = 0.5*(D13(NSEGH)+D13(NSEGHQ))
      D21(NSEGHP) = 0.5*(D21(NSEGH)+D21(NSEGHQ))
      D22(NSEGHP) = 0.5*(D22(NSEGH)+D22(NSEGHQ))
      D23(NSEGHP) = 0.5*(D23(NSEGH)+D23(NSEGHQ))
      D31(NSEGHP) = 0.5*(D31(NSEGH)+D31(NSEGHQ))
      D32(NSEGHP) = 0.5*(D32(NSEGH)+D32(NSEGHQ))
      D33(NSEGHP) = 0.5*(D33(NSEGH)+D33(NSEGHQ))
      E11(NSEGHP) = 0.0
      E12(NSEGHP) = 0.0
      E13(NSEGHP) = 0.0
      E21(NSEGHP) = 0.0
      E22(NSEGHP) = 0.0
      E23(NSEGHP) = 0.0
      E31(NSEGHP) = 0.0
      E32(NSEGHP) = 0.0
      E33(NSEGHP) = 0.0
C
C     CONSTRUCT JACOBIAN MATRICES
C
      AJC = 1.0
      CALL JACOB(NDIM1,NDIM1,NBAS1,NBAS1,PBAS1,QBAS1,
     >           EXPO1,E11,D11,AJC)
      DO 11 I=1,NDIM1
      DO 11 J=1,NDIM1
      AJIN11(I,J) = AJAC(I,J)
      AJIN22(I,J)=AJAC(I,J)
      AJIN33(I,J)=AJAC(I,J)
   11 CONTINUE
      AJC = 0.0
      CALL JACOB(NDIM1,NDIM2,NBAS1,NBAS2,PBAS2,QBAS1,
     >          EXPO2,E12,D12,AJC)
      DO 12 I=1,NDIM1
      DO 12 J=1,NDIM2
      AJIN12(I,J) = AJAC(I,J)
      AJIN23(I,J)=AJAC(I,J)
      AJIN31(I,J)=AJAC(I,J)
   12 CONTINUE
      AJC = 0.0
      CALL JACOB(NDIM1,NDIM3,NBAS1,NBAS3,PBAS3,QBAS1,
     >          EXPO3,E13,D13,AJC)
      DO 13 I=1,NDIM1
      DO 13 J=1,NDIM3
      AJIN13(I,J) = AJAC(I,J)
      AJIN21(I,J)=AJAC(I,J)
      AJIN32(I,J)=AJAC(I,J)
   13 CONTINUE
C
C     CONSTRUCT AND INVERT TOTAL JACOBIAN MATRIX
C
      NDIM1P = NDIM1+1
      NDIMS = NDIM1+NDIM2
      NDIMT = NDIMS+NDIM3
      NDIMSP = NDIMS+1
      DO 23 I=1,NDIM1
      DO 20 J=1,NDIM1
      AJINT(I,J) = AJIN11(I,J)
   20 CONTINUE
      DO 21 J=NDIM1P,NDIMS
      J1 = J-NDIM1
      AJINT(I,J) = AJIN12(I,J1)
   21 CONTINUE
      DO 22 J=NDIMSP,NDIMT
      J1 = J-NDIMS
      AJINT(I,J) = AJIN13(I,J1)
   22 CONTINUE
   23 CONTINUE
      DO 27 I=NDIM1P,NDIMS
      I1 = I-NDIM1
      DO 24 J=1,NDIM1
      AJINT(I,J) = AJIN21(I1,J)
   24 CONTINUE
      DO 25 J=NDIM1P,NDIMS
      J1 = J-NDIM1
      AJINT(I,J) = AJIN22(I1,J1)
   25 CONTINUE
      DO 26 J=NDIMSP,NDIMT
      J1 = J-NDIMS
      AJINT(I,J) = AJIN23(I1,J1)
   26 CONTINUE
   27 CONTINUE
      DO 31 I=NDIMSP,NDIMT
      I1 = I-NDIMS
      DO 28 J=1,NDIM1
      AJINT(I,J) = AJIN31(I1,J)
   28 CONTINUE
      DO 29 J=NDIM1P,NDIMS
      J1 = J-NDIM1
      AJINT(I,J) = AJIN32(I1,J1)
   29 CONTINUE
      DO 30 J=NDIMSP,NDIMT
      J1 = J-NDIMS
      AJINT(I,J) = AJIN33(I1,J1)
   30 CONTINUE
   31 CONTINUE
      DO 32 I=1,NDIMT
      DO 32 J=1,NDIMT
      UNIT(I,J) = 0.0
      UNIT(I,I) = 1.0
   32 CONTINUE
      NCON1=30
      NCON2=30
      NCON3=30
      NCON4=30
      NCON5=30
      IFAIL = 0
C      CALL F04AEF(AJINT,NCON1,UNIT,NCON2,NDIMT,NDIMT,SOLN,NCON3,
C     >            WORK,CROUT,NCON4,RESID,NCON5,IFAIL)
      CALL LINV2F(AJINT,NDIMT,NCON1,SOLN,6,WKAREA,IFAIL)
      IF (IFAIL.NE.0) GO TO 141
      DO 36 I=1,NDIM1
      DO 33 J=1,NDIM1
      AJIN11(I,J) = SOLN(I,J)
   33 CONTINUE
      DO 34 J=NDIM1P,NDIMS
      J1 = J-NDIM1
      AJIN12(I,J1) = SOLN(I,J)
   34 CONTINUE
      DO 35 J=NDIMSP,NDIMT
      J1 = J-NDIMS
      AJIN13(I,J1) = SOLN(I,J)
   35 CONTINUE
   36 CONTINUE
      DO 40 I=NDIM1P,NDIMS
      I1 = I-NDIM1
      DO 37 J=1,NDIM1
      AJIN21(I1,J) = SOLN(I,J)
   37 CONTINUE
      DO 38 J=NDIM1P,NDIMS
      J1 = J-NDIM1
      AJIN22(I1,J1) = SOLN(I,J)
   38 CONTINUE
      DO 39 J=NDIMSP,NDIMT
      J1 = J-NDIMS
      AJIN23(I1,J1) = SOLN(I,J)
   39 CONTINUE
   40 CONTINUE
      DO 44 I=NDIMSP,NDIMT
      I1 = I-NDIMS
      DO 41 J=1,NDIM1
      AJIN31(I1,J) = SOLN(I,J)
   41 CONTINUE
      DO 42 J=NDIM1P,NDIMS
      J1 = J-NDIM1
      AJIN32(I1,J1) = SOLN(I,J)
   42 CONTINUE
      DO 43 J=NDIMSP,NDIMT
      J1 = J-NDIMS
      AJIN33(I1,J1) = SOLN(I,J)
   43 CONTINUE
   44 CONTINUE
C
C     DETERMINE NEW COEFFICIENTS OF COARSE REPRESENTATION
C
      DO 54 I=1,NDIM1
      DBAS1(I) = 0.0
      DO 54 L=1,LMAX1
      DBAS1(I) = DBAS1(I)+QBAS1(I,L)*X1(L)
   54 CONTINUE
      DO 55 I=1,NDIM1
      DBAS1(I) = CBAS1(I)-DBAS1(I)
   55 CONTINUE
      DO 56 I=1,NDIM2
      DBAS2(I) = 0.0
      DO 56 L=1,LMAX2
      DBAS2(I) = DBAS2(I)+QBAS2(I,L)*X2(L)
   56 CONTINUE
      DO 57 I=1,NDIM2
      DBAS2(I) = CBAS2(I)-DBAS2(I)
   57 CONTINUE
      DO 58 I=1,NDIM3
      DBAS3(I) = 0.0
      DO 58 L=1,LMAX3
      DBAS3(I) = DBAS3(I)+QBAS3(I,L)*X3(L)
   58 CONTINUE
      DO 59 I=1,NDIM3
      DBAS3(I) = CBAS3(I)-DBAS3(I)
   59 CONTINUE
C
C
C     CALCULATE SQUARED NORMS OF TOTAL AND COARSE
C     DISCREPANCIES
C
      DTOT1 = 0.0
      DTOT2 = 0.0
      DTOT3 = 0.0
      CALL DISC(NDIM1,ABAS1,DBAS1,C1,X1)
      DTOT1 = DTOT
      CALL DISC(NDIM2,ABAS2,DBAS2,C2,X2)
      DTOT2 = DTOT
      CALL DISC(NDIM3,ABAS3,DBAS3,C3,X3)
      DTOT3 = DTOT
      IF (ACCTOT-DTOT1) 138,138,135
  135 IF (ACCTOT-DTOT2) 138,138,136
  136 IF (ACCTOT-DTOT3) 138,138,137
  137 IEND = 1
  138 CONTINUE
      RETURN
  139 CONTINUE
      WRITE(*,777)SS1,SS2
  777 FORMAT(1X,'SS1 SS2== ',2E20.12)
  140 CONTINUE
  141 WRITE(*,600)IFAIL
  600 FORMAT(1X,'IFAIL-- ',I5,' STOP AT THE END OF CALFUN ')
  608 FORMAT(1H0,'MATRIX FOR 12,22 COMPONENT'/)
      STOP
      END
C
C
C
C
      FUNCTION FREE(PI,NX,DHS,RHO,POTE)
      IMPLICIT REAL*8(A-H,O-Z)
C      PARAMETER(MX=4096)
      PARAMETER(MX=1024)
      COMMON/SEG/DR,XKSEG,NSEC
      COMMON/HRK/HR(MX),GR(MX),HK(MX)
      COMMON/SNO/CK(MX),CR(MX)
      DIMENSION POTE(NX)

      DCU=DHS*DHS*DHS
      ETA=PI*RHO*DCU/6.0
      SK=1.0/(1.0-RHO*CK(1))
      WRITE(*,888)ETA,SK
  888 FORMAT(1X,'ETA SK*******  ',2E20.12)

      PI4=4.0*PI
      CUT=1.0 E-12

      NH=NX/2
      NH1=NH-1
      SUMRG=0.0

      DO 200 I=2,NH1
        ABSG=DABS(GR(I))
        IF(ABSG.LE.CUT)GO TO 199
        VI=FLOAT(I-1)
        RI=VI*DR
        TG=POTE(I)+DLOG(GR(I))
        SUMRG=SUMRG+GR(I)*TG*RI*RI
  199   CONTINUE
  200 CONTINUE

      TG=POTE(NH)+DLOG(GR(NH))
      VI=FLOAT(NH-1)
      RI=VI*DR
      RGLAST=0.50*GR(NH)*TG*RI*RI
      SUMRG=SUMRG+RGLAST

      SUMRH=0.0

      DO 300 I=2,NH1
        VI=FLOAT(I-1)
        RI=VI*DR
        TH=0.50*HR(I)+1.0
        SUMRH=SUMRH+HR(I)*TH*RI*RI
  300 CONTINUE

      VI=FLOAT(NH-1)
      RI=VI*DR
      RHLAST=HR(NH)*(0.50*HR(NH)+1.0)*0.50*RI*RI
      SUMRH=SUMRH+RHLAST
      SUMR=PI4*0.50*RHO*DR*(SUMRG-SUMRH)

      SUMK=0.0

      DK=2.0*PI/(FLOAT(NX)*DR)


      DO 400 I=2,NH1
        VI=FLOAT(I-1)
        XK=VI*DK
        RHK=RHO*HK(I)
        TK=DLOG(1.0+RHK)-RHK
        SUMK=SUMK+TK*XK*XK
  400 CONTINUE

      VI=FLOAT(NH-1)
      XK=VI*DK
      RHKN=RHO*HK(NH)
      SKLAST=(DLOG(1.0+RHKN)-RHKN)*XK*XK

      SUMK=0.50*SKLAST+SUMK
      CONSTK=16.0*PI*PI*PI*RHO

      SUMK=PI4*DK*SUMK/CONSTK

      FREE=SUMR-SUMK

      RETURN
      END
C
C
C
C
C
C
C
C
      SUBROUTINE FINCRS
      IMPLICIT REAL*8(A-H,O-Z)
C      PARAMETER(MX=4096)
      PARAMETER(MX=1024)
      COMMON/SEG/XXSEG,XKSEG,NSEG
      COMMON/ND/NDIM1,NDIM2,NDIM3
      COMMON/NB2/NBAS1(10),NBAS2(10),NBAS3(10)
      COMMON/CB/CBAS1(10),CBAS2(10),CBAS3(10)
      COMMON/DB/DBAS1(10),DBAS2(10),DBAS3(10)
      COMMON/QB/QBAS1(10,100),QBAS2(10,100),QBAS3(10,100)
      COMMON/PB/PBAS1(10,100),PBAS2(10,100),PBAS3(10,100)
      COMMON/X/X1(MX),X2(MX),X3(MX)
      COMMON/Y/Y1(MX),Y2(MX),Y3(MX)
      COMMON/CRS/CBAS(10)
      COMMON/FIN/NPRINT,NREM,Y(MX),DBAS(10)
      COMMON/COUNT/NCNT,MODE,ACCTOT
C      COMMON/COUNT/NCNT,MADE,ACCTOT
      COMMON/ID/IEND

      NCNT=0
      IEND=0

      DO 22 NREM=1,100
      CALL FINE(NDIM1,NBAS1,CBAS1,PBAS1,X1)
      DO 13 N=1,NDIM1
      DBAS1(N)=DBAS(N)
      DBAS2(N)=DBAS(N)
      DBAS3(N)=DBAS(N)
   13 CONTINUE
      DO 14 I=1,NSEG
      Y1(I)=Y(I)
      Y2(I)=Y(I)
      Y3(I)=Y(I)
   14 CONTINUE
      CALL SOLVE
      IF(IEND.EQ.1)GO TO 131

      CALL COARSE(NDIM1,NBAS1,QBAS1,X1)
      DO 19 I=1,NDIM1
      CBAS1(I)=CBAS(I)
      CBAS2(I)=CBAS(I)
      CBAS3(I)=CBAS(I)
   19 CONTINUE
   22 CONTINUE
  131 CONTINUE
  132 CONTINUE

      RETURN
      END
C
C
C
C
      SUBROUTINE BRIDGE(NX,NB,RHO,PI)
      IMPLICIT REAL*8(A-H,O-Z)
C      PARAMETER(MX=4096)
      PARAMETER(MX=1024)
      COMMON/II/INDEX,DELTA,INXTAL
      COMMON/SEG/DR,XKSEG,NSEG
      COMMON/YBG/YR(MX),BR(MX),GMK(MX)
      COMMON/BXW/X(MX),WORK(MX),BD(2,MX),DD(2)
      COMMON/EX/ET(0:100),XI(0:100),EW(4),XW(4)

      ETA=0.0
      STEP=2.0*DELTA
      PR=PI*RHO
      XPN=1.0/3.0


      INDEX=0
      ETA=ETA+STEP
      XI(1)=ETA
      DHS=(6.0*ETA/PR)**XPN
      SUM1=CORPY(NX,PI,RHO,DHS)
      ET(1)=0.250*SUM1*STEP
      INDEX=1


      DO 30 L=2,NB
        ETA=ETA+STEP
        XI(L)=ETA
        DHS=(6.0*ETA/PR)**XPN
        SUMT=CORPY(NX,PI,RHO,DHS)
        ET(L)=(SUM1+0.50*SUMT)*STEP*0.50
        SUM1=SUM1+SUMT
   30 CONTINUE


      DO 200 K=1,NX
        BR(K)=0.0
  200 CONTINUE

      RETURN
      END
C
C
C
C
      FUNCTION CORPY(NX,PI,RHO,DHS)
      IMPLICIT REAL*8(A-H,O-Z)
C      PARAMETER(MX=4096)
      PARAMETER(MX=1024)
      COMMON/II/INDEX,DELTA,INXTAL
      COMMON/SEG/DR,XKSEG,NSEG
      COMMON/YBG/YR(MX),BR(MX),GMK(MX)
      COMMON/BXW/X(MX),WORK(MX),BD(2,MX),DD(2)
        DIMENSION YF(2048)
      NX2=NX/2
      PR=PI*RHO
      ETA=PR*DHS*DHS*DHS/6.0
      ETA1=ETA-DELTA
      ETA2=ETA+DELTA
      XPN=1.0/3.0
      DD(1)=(6.0*ETA1/PR)**XPN
      DD(2)=(6.0*ETA2/PR)**XPN

      ISTART=INDEX+1


      DO 100 I=ISTART,2
        CALL SETBR(NX,PI,RHO,DD(I))

        DO 50 J=1,NX2
          BD(I,J)=BR(J)
   50   CONTINUE
  100 CONTINUE

      CALL INITIA(PI,DHS,RHO,NX,A,B,ET0)
      CALL FOURIE(PI,GMK,YR,NX,DR,1,X,YF,WORK)



      DO 55 I=1,NX2
        YR(I)=1.0+YR(I)
   55 CONTINUE

      DL2=2.0*DELTA
      IX=0

  150 CONTINUE
      R=IX*DR
      IX=IX+1
      IF(R.LT.DHS)GO TO 150

      IX1=IX+1
      SUM=0.0
      NH1=NX2-1
      DO 200 I=IX1,NH1
        VI=FLOAT(I-1)
        RI=VI*DR
        DBDE=(BD(2,I)-BD(1,I))/DL2
        SUM=SUM+YR(I)*DBDE*RI*RI
  200 CONTINUE

      VI=FLOAT(NX2-1)
      RI=VI*DR
      DBDE=(BD(2,NX2)-BD(1,NX2))/DL2
      TERML=0.50*YR(NX2)*DBDE*RI*RI
      SUM=(TERML+SUM)*DR

      CORPY=RHO*SUM*PI*4.0



      DO 300 J=1,NX2
        BD(1,J)=BD(2,J)
  300 CONTINUE

      RETURN
      END
C
C
C
C
      SUBROUTINE SETBR(NX,PI,RHO,DHS)
      IMPLICIT REAL*8(A-H,O-Z)
C      PARAMETER(MX=4096)
      PARAMETER(MX=1024)
      COMMON/SEG/DEL,XKSEG,NSEG
      COMMON/YBG/YR(MX),BR(MX),GMK(MX)
      COMMON/BXW/X(MX),WORK(MX),BD(2,MX),DD(2)
        DIMENSION YF(2048)
C
      NX1=NX-1
      NX2=NX/2
      INV=1

      CALL INITIA(PI,DHS,RHO,NX,A,B,ET0)
      CALL FOURIE(PI,GMK,YR,NX,DEL,INV,X,YF,WORK)

      DO 50 I=1,NX2
        YR(I)=1.0+YR(I)
   50 CONTINUE

      CALL BRDG(NX2,A,B,ET0,DHS)

      DO 60 L=NX2,NX
        BR(L)=0.0
   60 CONTINUE

      RETURN
      END
C
C
C
C
      SUBROUTINE BRDG(NX,A,B,ET0,DHS)
      IMPLICIT REAL*8(A-H,O-Z)
C      PARAMETER(MX=4096)
      PARAMETER(MX=1024)
      COMMON/SEG/DEL,SKSEG,NSEG
      COMMON/YBG/YR(MX),BR(MX),GMK(MX)

      DRD=DEL/DHS
      ZZ=0.50*ET0*A
      D3=DHS*DHS*DHS
C     ZZ=ZZ/D3
      L=1
  300 CONTINUE
      S=(L-1)*DRD
      YR(L)=-(A+(B+ZZ*S*S)*S)
      L=L+1
      IF(S.LT.1.0)GO TO 300

      ZERO=0.00010

      DO 100 L=2,NX
        IF(YR(L).GT.ZERO)GO TO 444
        WRITE(*,555)L,YR(L),ET0,DHS
  555   FORMAT(1X,'L YR ET0 DHS ',I5,2X,3E20.12)
        WRITE(*,666)A,B
  666   FORMAT(1X,'A B=== ',2E20.12)
  444  CONTINUE
        DLY=DLOG(YR(L))
        BR(L)=YR(L)-1.0-DLY
  100 CONTINUE

      RETURN
      END
C
C
C
C
      SUBROUTINE FOURIE(PI,ARK,ARY,NX,DX,INV,X,YF,WORK)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION ARK(NX),ARY(NX)
      DIMENSION X(NX),WORK(NX),YF(NX)

C      INV=0 R TO K ;   INV=1   K TO R  ;


      NH=NX/2
      PIN=PI/(NX*1.0)
      DY=2.0*PIN/DX
      EN=FLOAT(NX)
      RN=DSQRT(EN)


      IF(INV.EQ.1)GO TO 551
      CONST=4.0*PI*DX*DX*DX
      GO TO 555
 551  CONST=DY*DY*DY/(2.0*PI*PI)
 555  CONTINUE

      SUM0=0.0
      DO 80 J=1,NH
        VJ=(J-1)*1.0
        SUM0=SUM0+VJ*VJ*ARK(J)
  80  CONTINUE

      ARY(1)=CONST*SUM0

      IF(INV.EQ.1)GO TO 661
      CONST=4.0*PI*DX*DX/DY
      GO TO 666
 661  CONST=DY*DY/(2.0*PI*PI*DX)
 666  CONTINUE


      DO 150 I=1,NH
        VI=FLOAT(I-1)
        X(I)=ARK(I)*VI
        X(I+NH)=0.0
        YF(I)=0.0
        YF(I+NH)=0.0
  150 CONTINUE

C      IFAIL=0
C      CALL C06FAF(X,NX,WORK,IFAIL)
C
C
      IF1=0
      CALL C06GCF(YF,NX,IF1)
      IFAIL=0
      CALL C06FCF(X,YF,NX,IFAIL)
      IF3=0
      CALL C06GCF(YF,NX,IF3)

      N2=NX+2

C      DO 100 M=2,NH
C        X(M)=-RN*X(N2-M)
C
C
C
       DO 100 M = 2,NH
       X(M) = RN*YF(M)


  100 CONTINUE

      DO 200 I=2,NH
        VI=FLOAT(I-1)
        ARY(I)=CONST*X(I)/VI
  200 CONTINUE
      RETURN
      END
C
C
C
C
      SUBROUTINE INITIA(PI,D,RHO,NX,A,B,ET0)
      IMPLICIT REAL*8(A-H,O-Z)
C      PARAMETER(MX=4096)
      PARAMETER(MX=1024)
      COMMON/SEG/DR,SKSEG,NSEG
      COMMON/YBG/YR(MX),BR(MX),GMK(MX)

      DK=2.0*PI/(NX*DR)
C     DHS=D
C     ETA=PI*RHO*D*D*D/6.0
C     FACTR=(1.0-ETA/16.0)**(1.0/3.0)
C     D=D*FACTR
C      SEE HENDERSON & GRUNDKE JCP 63,601 (1975)

      DK3=DK*DK*DK
      ET0=PI*RHO*D*D*D/6.0
      EM=1.0-ET0
      EM3=EM*EM*EM
      EM4=EM*EM3

      A=-(1.0+2.0*ET0)*(1.0+2.0*ET0)/EM4
      B=6.0*ET0*(1.0+0.50*ET0)*(1.0+0.50*ET0)/EM4

      CN=4.0*PI*D*D*D
      P4=4.0*PI
      CN2=ET0*A/2.0
      DKD=DK*D

      DO 100 J=2,NX
        VK=(J-1)*DKD
C       ZK=(J-1)*DK
C       ZK2=ZK*ZK
C       ZK3=ZK2*ZK
        COSK=DCOS(VK)
        SINK=DSIN(VK)
        VK2=VK*VK
        VK3=VK2*VK
        VK4=VK3*VK

        T1=A*(VK*COSK-SINK)
        T2=B*(VK2*COSK-2.0*VK*SINK-2.0*COSK+2.0)
        T2=T2/VK
        X1=VK4*COSK-4.0*VK3*SINK-12.0*VK2*COSK
        X2=24.0*VK*SINK+24.0*COSK-24.0
        CK=-CN*(T1+T2+CN2*(X1+X2)/VK3)/VK3
        RC=RHO*CK
        GMK(J)=RC*CK/(1.0-RC)

  100 CONTINUE

C     D=DHS

      RETURN
      END
C
C
C
C
      FUNCTION FINTR(X,NT,FV,XV)
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION FV(NT),XV(NT)

      DO 20 J=1,NT
        IF(X.NE.XV(J))GO TO 20
        FINTR=FV(J)
        GO TO 999
   20 CONTINUE

      SUM=0.0

      DO 100 I=1,NT
        PRDCT=1.0
        DO 50 L=1,NT
          IF(I.EQ.L)GO TO 50
          TM=(X-XV(L))/(XV(I)-XV(L))
          PRDCT=PRDCT*TM
   50   CONTINUE
        SUM=SUM+FV(I)*PRDCT
  100 CONTINUE

      FINTR=SUM
  999 CONTINUE

      RETURN
      END
C
C
C
C
C
C
C
C
      FUNCTION FCSPYC(ETA)
      IMPLICIT REAL*8(A-H,O-Z)

      E1=1.0-ETA
      X1=DLOG(E1)
      X2=2.0/E1-0.50/(E1*E1)
      FCSPYC=X1+X2-1.50

      RETURN
      END
C
C
C
C
      FUNCTION FCSPYV(ETA)
      IMPLICIT REAL*8(A-H,O-Z)

      E1=1.0-ETA
      FCS=(4.0-3.0*ETA)*ETA/(E1*E1)
      FPY=6.0*ETA/E1+2.0*DLOG(E1)
      FCSPYV=FCS-FPY

      RETURN
      END
C
C
C
C
      FUNCTION BFMHNC(NX,NB,ETA,PI,DENS,X,POT,MODE)
      IMPLICIT REAL*8(A-H,O-Z)
C      PARAMETER(MX=4096)
      PARAMETER(MX=1024)
      COMMON/EX/ET(0:100),XI(0:100),EW(4),XW(4)
      COMMON/II/INDEX,DELTA,INXTAL
      COMMON/ZT/Z1,Z2,T,ZREAL
      DIMENSION X(MX),POT(MX)

      XPN=1.0/3.0

      ZERO=0.000010
      IF(ETA.LT.ZERO)GO TO 100
      DHS=(6.0*ETA/(PI*DENS))**XPN
      CALL SETBR(NX,PI,DENS,DHS)
  100 CONTINUE
C      CALL POTEN(NX)
      CALL  POTEN
      CALL FINCRS
      WRITE(*,123)INXTAL,T
      CALL FINAL(X,POT,MODE,NX,PI)
      BF=FREE(PI,NX,DHS,DENS,POT)
      FV=FCSPYV(ETA)
      FC=FCSPYC(ETA)
      IF(ETA.LT.ZERO)GO TO 200
      FB=BSUM(NB,ETA)
      GO TO 250
  200 FB=0.0
  250 CONTINUE
      WRITE(*,707)ETA,BF,FV,FC,FB
  707 FORMAT(1X,'ETA= ',F10.6,'  BF FV,FC FB== ',4E20.12)
      B0=BF-FB
      BC=B0+FC
      BV=B0+FV
      BVIN=B0-FV
      WRITE(*,747)B0,BC,BV,BVIN
  747 FORMAT(1X,' BFMHNC 0 C V VIN===  ',4E20.12)

      BFMHNC=BV
  123 FORMAT(1X,'INXTAL T== ',I5,2X,E20.12)

      RETURN
      END
C
C
C
C
      SUBROUTINE INTERP(NX,NB,PI,DENS,X1,VPOT1,MODE,MIN,I,ERR,STEP)
      IMPLICIT REAL*8(A-H,O-Z)
C      PARAMETER(MX=4096)
      PARAMETER(MX=1024)
      COMMON/EF/XFR(50),FFR(50),XM(3),FM(3)
      COMMON/II/INDEX,DELTA,INXTAL
      DIMENSION X1(MX),VPOT1(MX)

      LIMIT=4
      IOK=0
      XERR=0.10*ERR
      FM(2)=FFR(MIN)
      XM(2)=XFR(MIN)
      LM=0
  100 CONTINUE
      CALL MINZ(I,MIN,XERR,STEP)
      FMIN=FM(2)
      XMIN=XM(2)
      CALL CHECK(ERR,FMIN,XMIN,I,IOK,NX,NB,PI,DENS,X1,VPOT1,MODE)
      CALL INSERT(I,FMIN,XMIN)
      IF(IOK.EQ.1)GO TO 999
      LM=LM+1
      IF(LM.LT.LIMIT)GO TO 100
  999 CONTINUE
      WRITE(*,123)XMIN,FMIN
  123 FORMAT(1X,'FINAL MIN ETA,BF== ',2E20.12)

      DO 200 J=1,I
        WRITE(*,250)J,XFR(J),FFR(J)
  200 CONTINUE
  250 FORMAT(1X,I4,' ETA BF..... ',2E20.12)


      RETURN
      END
C
C
C
C
      SUBROUTINE INSERT(I,FMIN,XMIN)
      IMPLICIT REAL*8(A-H,O-Z)
      COMMON/EF/XFR(50),FFR(50),XM(3),FM(3)

      I=I+1
      IP=I

  100 CONTINUE
      IF(XMIN.GT.XFR(IP-1))GO TO 120
      FFR(IP)=FFR(IP-1)
      XFR(IP)=XFR(IP-1)
      IP=IP-1
      GO TO 100

  120 CONTINUE
      FFR(IP)=FMIN
      XFR(IP)=XMIN



      RETURN
      END
C
C
C
C
      SUBROUTINE MINZ(I,MIN,XERR,STEP)
      IMPLICIT REAL*8(A-H,O-Z)
      COMMON/EF/XFR(50),FFR(50),XM(3),FM(3)

      XM(2)=XFR(MIN)
      IF(MIN.EQ.1)XM(2)=XFR(2)
      IF(MIN.EQ.I)XM(2)=XFR(I-1)
      DT1=DABS(XFR(1)-XM(2))
      DT2=DABS(XFR(I)-XM(2))
      XSTEP=DT1
      IF(DT2.LT.DT1)XSTEP=DT2
      FM(2)=FINTR(XM(2),I,FFR,XFR)

  100 CONTINUE
      XM(1)=XM(2)-XSTEP
      XM(3)=XM(2)+XSTEP
      FM(1)=FINTR(XM(1),I,FFR,XFR)
      FM(3)=FINTR(XM(3),I,FFR,XFR)

      NMIN=1
      IF(FM(2).LT.FM(1))NMIN=2
      IF(FM(3).LT.FM(NMIN))NMIN=3

      XM(2)=XM(NMIN)
      FM(2)=FM(NMIN)
      XSTEP=0.50*XSTEP
      IF(XSTEP.GE.XERR)GO TO 100


      RETURN
      END
C
C
C
C
      SUBROUTINE CHECK(ERR,FMIN,XMIN,I,IOK,NX,NB,PI,DENS,X1,VPOT1,MODE)
      IMPLICIT REAL*8(A-H,O-Z)
C      PARAMETER(MX=4096)
      PARAMETER(MX=1024)
      COMMON/EF/XFR(50),FFR(50),XM(3),FM(3)
      COMMON/II/INDEX,DELTA,INXTAL
      DIMENSION X1(MX),VPOT1(MX)

      FNEW=BFMHNC(NX,NB,XMIN,PI,DENS,X1,VPOT1,MODE)
      ECHCK=DABS(FNEW-FMIN)


      IF(ECHCK.LT.ERR)IOK=1
      WRITE(*,100)FNEW,FMIN,ECHCK
  100 FORMAT(1X,'FNEW FMIN ECHCK== ',3E20.12)
      FMIN=FNEW

      RETURN
      END
C
C
C
C
      SUBROUTINE BSETUP
      IMPLICIT REAL*8(A-H,O-Z)
C      PARAMETER(MX=4096,NX=2048)
      PARAMETER(MX=1024,NX=512)
      COMMON/ND/NDIM1,NDIM2,NDIM3
      COMMON/NB2/NBAS1(10),NBAS2(10),NBAS3(10)
      COMMON/AB/ABAS1(10,10),ABAS2(10,10),ABAS3(10,10)
      COMMON/BB/BBAS1(10,10),BBAS2(10,10),BBAS3(10,10)
      COMMON/CB/CBAS1(10),CBAS2(10),CBAS3(10)
      COMMON/QB/QBAS1(10,100),QBAS2(10,100),QBAS3(10,100)
      COMMON/PB/PBAS1(10,100),PBAS2(10,100),PBAS3(10,100)
      COMMON/X/X1(MX),X2(MX),X3(MX)
      COMMON/BS/ABAS(10,10),BBAS(10,10),PBAS(10,100)
      COMMON/BS/QBAS(10,100),LMAX
      COMMON/CRS/CBAS(10)
C
      CALL BASIS(NBAS1,NDIM1)
      DO 4 N=1,NDIM1
      DO 4 L=1,LMAX
      PBAS1(N,L) = PBAS(N,L)

      QBAS1(N,L) = QBAS(N,L)
      PBAS2(N,L)=PBAS(N,L)
      QBAS2(N,L)=QBAS(N,L)
      PBAS3(N,L)=PBAS(N,L)
      QBAS3(N,L)=QBAS(N,L)
    4 CONTINUE
      DO 5 I=1,NDIM1
      DO 5 J=1,NDIM1
      ABAS1(I,J) = ABAS(I,J)
      BBAS1(I,J) = BBAS(I,J)
      ABAS2(I,J)=ABAS(I,J)
      BBAS2(I,J)=BBAS(I,J)
      ABAS3(I,J)=ABAS(I,J)
      BBAS3(I,J)=BBAS(I,J)
    5 CONTINUE
C
C     FETCH INITIAL ESTIMATE FOR THE XIJ
C
      WRITE(*,*)'DOES AN INITIAL ESTIMATION EXIST? '
C        ACCEPT*,IOPTION
       READ(*,*) IOPTION
        IF (IOPTION.EQ.0) THEN
      CALL HS
        ELSE
C     OPEN (53,FILE='INIT5',STATUS='OLD')
      OPEN (53,FILE='INIT5')
        DO I=1,NX/2
        READ(53,*) X1(I)
        X2(I)=X1(I)
        X3(I)=X1(I)
        ENDDO
      CLOSE(53)
        ENDIF
C
C     DECOMPOSE THE XIJ INTO COARSE AND FINE PARTS
C
      CALL COARSE(NDIM1,NBAS1,QBAS1,X1)
      DO 10 I=1,NDIM1
      CBAS1(I) = CBAS(I)
      CBAS2(I)=CBAS(I)
      CBAS3(I)=CBAS(I)
   10 CONTINUE

      RETURN
      END
C
C
C
C
      SUBROUTINE VFEED(ITYPE,NX,DENS,SG)
      IMPLICIT REAL*8(A-H,O-Z)
C      PARAMETER(MX=4096)
      PARAMETER(MX=1024)
      COMMON/SEG/DR,XKSEG,NSEG
      COMMON/VB/VBARE(3,MX),TAL(20),AD,AF

      IF(ITYPE.EQ.2)GO TO 200

      OPEN(1,FILE='FOR051.DAT')
      READ(1,*)RDC
      READ(1,*)DENS
      READ(1,*)MAXR,ISTEP,DROLD
      STEP=FLOAT(ISTEP)
      DR=STEP*DROLD
      I=2
   99 READ(1,*,END=100)INDX,VBARE(1,I),VBARE(2,I),VBARE(3,I)
      I=I+1
      GOTO 99
  100 CONTINUE
      CLOSE(1)

       GO TO 999
  200  CONTINUE
C       T4 EQUALS 4.0*119.8
       T4=479.2
       DO 300,I=2,NX
         XX=FLOAT(I-1)*DR
         XR=(SG/XX)**6.0
         VBARE(1,I)=T4*XR*(XR-1.0)
  300  CONTINUE
         VBARE(1,1)=1.0D30
  999  CONTINUE


      WRITE(*,333)RDC
  333 FORMAT(1X,' CORE RADIUS RC=== ',E20.12)

      RETURN
      END
C
C
C
C
      FUNCTION BSUM(NB,ETA)
      IMPLICIT REAL*8(A-H,O-Z)
      COMMON/EX/ET(0:100),XI(0:100),EW(4),XW(4)


      L=1
  100 IF(ETA.LE.XI(L))GO TO 150
      L=L+1
      GO TO 100
  150 NB1=NB-1
      IF(L.GE.3)GO TO 200
      KF=0
      KL=4
      GO TO 300
  200 IF(L.LT.NB1)GO TO 250
      KF=NB-3
      KL=NB
      GO TO 300
  250 KF=L-2
      KL=L+1
  300 NZ=0
      DO 350 M=KF,KL
        NZ=NZ+1
        XW(NZ)=XI(M)
        EW(NZ)=ET(M)
  350 CONTINUE
      BSUM=FINTR(ETA,NZ,EW,XW)

      RETURN
      END
C
C**************************************
C                                     *
C      SUBROUTINE CONJUGATION         *
C**************************************


      SUBROUTINE C06GCF(Y,N,IFAIL)
C      REAL*8 Y(2048)
      REAL*8 Y(512)
C
C
      DO 1 I = 1,N
              Y(I) = - Y(I)
    1 CONTINUE
      RETURN
      END
C
C
C**************************************
C                                     *
C     SUBROUTINE INTEGRATION          *
C                                     *
C**************************************

      SUBROUTINE D01GAF(X,Y,N,ANS)
C      REAL*8  X(2048),Y(2048),ANS
      REAL*8  X(512),Y(512),ANS
C
      ANS=Y(1)+3.D0*Y(2)+3.D0*Y(3)+Y(N)
      DO I=4,N-3,3
          ANS=ANS+2.D0*Y(I)+3.D0*Y(I+1)+3.D0*Y(I+2)
      ENDDO
      ANS= ANS*(X(2)-X(1))*3.D0/8.D0
      RETURN
      END
C
C
C
C******************************************
C                                         *
C     SUBROUTINE FOURIER TRANSFORM        *
C                                         *
C******************************************
C
      SUBROUTINE C06FCF(X,Y,N,IFAIL)
C      REAL*8 X(2048),Y(2048),UR,UI,TR,TI,WR,WI,PI
      REAL*8 X(512),Y(512),UR,UI,TR,TI,WR,WI,PI

      PI=3.1415926535
      LN=LOG(FLOAT(N))/LOG(2.)+.5D0
C
C     REORDENAMIENTO
C
      J=1
      DO 3 I=1,N-1
      IF(I.GE.J) GOTO 1
      TR=X(J)
      TI=Y(J)
      X(J)=X(I)
      Y(J)=Y(I)
      X(I)=TR
      Y(I)=TI
    1 K=N/2
    2 IF (K.GE.J) GOTO 3
      J=J-K
      K=K/2
      GO TO 2
    3 J=J+K
C
C     CALCULO
C
      DO 5 L=1,LN
            LE=2**L
            LE1=LE/2
            UR=1.D0
            UI=0.D0
            WR=COS(PI/LE1)
            WI=-SIN(PI/LE1)
            DO 5 J=1,LE1
                    DO 4 I=J,N,LE
                           IP=I+LE1
                           TR=X(IP)*UR - Y(IP)*UI
                           TI=X(IP)*UI + Y(IP)*UR
                           X(IP)= X(I)-TR
                           Y(IP) = Y(I) -TI
                           X(I)= X(I)+TR
   4                 Y(I)=Y(I) +TI
             TR=UR
             UR=UR*WR-UI*WI
   5  UI=TR*WI+UI*WR
C
C
C    FINAL
C
      ROOTN=DSQRT(DFLOAT(N))
      DO 6 I=1,N
              X(I)=X(I)/ROOTN
              Y(I)=Y(I)/ROOTN
   6  CONTINUE
      RETURN
      END
****************************


C   IMSL ROUTINE NAME   - LINV2F                                        LI2F0010
C                                                                       LI2F0020
C-----------------------------------------------------------------------LI2F0030
C                                                                       LI2F0040
C   COMPUTER            - VAX/DOUBLE                                    LI2F0050
C                                                                       LI2F0060
C   LATEST REVISION     - JUNE 1, 1982                                  LI2F0070
C                                                                       LI2F0080
C   PURPOSE             - INVERSION OF A MATRIX - FULL STORAGE MODE -   LI2F0090
C                           HIGH ACCURACY SOLUTION                      LI2F0100
C                                                                       LI2F0110
C   USAGE               - CALL LINV2F (A,N,IA,AINV,IDGT,WKAREA,IER)     LI2F0120
C                                                                       LI2F0130
C   ARGUMENTS    A      - INPUT MATRIX OF DIMENSION N BY N CONTAINING   LI2F0140
C                           THE MATRIX TO BE INVERTED.                  LI2F0150
C                N      - ORDER OF A. (INPUT)                           LI2F0160
C                IA     - ROW DIMENSION OF MATRICES A AND AINV EXACTLY  LI2F0170
C                           AS SPECIFIED IN THE DIMENSION STATEMENT IN  LI2F0180
C                           THE CALLING PROGRAM. (INPUT)                LI2F0190
C                AINV   - OUTPUT MATRIX OF DIMENSION N BY N CONTAINING  LI2F0200
C                           THE INVERSE OF A. A AND AINV MUST OCCUPY    LI2F0210
C                           SEPARATE CORE LOCATIONS.                    LI2F0220
C                IDGT   - INPUT OPTION.                                 LI2F0230
C                         IF IDGT IS GREATER THAN 0, THE ELEMENTS OF A  LI2F0240
C                           ARE ASSUMED TO BE CORRECT TO IDGT DECIMAL   LI2F0250
C                           DIGITS AND THE ROUTINE PERFORMS AN ACCURACY LI2F0260
C                           TEST.                                       LI2F0270
C                         IF IDGT EQUALS 0, THE ACCURACY TEST IS        LI2F0280
C                           BYPASSED.                                   LI2F0290
C                         ON OUTPUT, IDGT CONTAINS THE APPROXIMATE      LI2F0300
C                           NUMBER OF DIGITS IN THE ANSWER WHICH        LI2F0310
C                           WERE UNCHANGED AFTER IMPROVEMENT.           LI2F0320
C                WKAREA - WORK AREA OF DIMENSION GREATER THAN OR EQUAL  LI2F0330
C                           TO N**2+3N.                                 LI2F0340
C                IER    - ERROR PARAMETER. (OUTPUT)                     LI2F0350
C                         TERMINAL ERROR                                LI2F0360
C                           IER=129 INDICATES THAT THE MATRIX IS        LI2F0370
C                             ALGORITHMICALLY SINGULAR. (SEE THE        LI2F0380
C                             CHAPTER L PRELUDE).                       LI2F0390
C                           IER=131 INDICATES THAT THE MATRIX IS TOO    LI2F0400
C                             ILL-CONDITIONED FOR ITERATIVE IMPROVEMENT LI2F0410
C                             TO BE EFFECTIVE.                          LI2F0420
C                         WARNING ERROR                                 LI2F0430
C                           IER=34 INDICATES THAT THE ACCURACY TEST     LI2F0440
C                             FAILED. THE COMPUTED SOLUTION MAY BE IN   LI2F0450
C                             ERROR BY MORE THAN CAN BE ACCOUNTED FOR   LI2F0460
C                             BY THE UNCERTAINTY OF THE DATA. THIS      LI2F0470
C                             WARNING CAN BE PRODUCED ONLY IF IDGT IS   LI2F0480
C                             GREATER THAN 0 ON INPUT. SEE CHAPTER L    LI2F0490
C                             PRELUDE FOR FURTHER DISCUSSION.           LI2F0500
C                                                                       LI2F0510
C   PRECISION/HARDWARE  - SINGLE AND DOUBLE/H32                         LI2F0520
C                       - SINGLE/H36,H48,H60                            LI2F0530
C                                                                       LI2F0540
C   REQD. IMSL ROUTINES - SINGLE/LEQT2F,LUDATN,LUELMN,LUREFN,UERTST,    LI2F0550
C                           UGETIO                                      LI2F0560
C                       - DOUBLE/LEQT2F,LUDATN,LUELMN,LUREFN,UERTST,    LI2F0570
C                           UGETIO,VXADD,VXMUL,VXSTO                    LI2F0580
C                                                                       LI2F0590
C   NOTATION            - INFORMATION ON SPECIAL NOTATION AND           LI2F0600
C                           CONVENTIONS IS AVAILABLE IN THE MANUAL      LI2F0610
C                           INTRODUCTION OR THROUGH IMSL ROUTINE UHELP  LI2F0620
C                                                                       LI2F0630
C   COPYRIGHT           - 1978 BY IMSL, INC. ALL RIGHTS RESERVED.       LI2F0640
C                                                                       LI2F0650
C   WARRANTY            - IMSL WARRANTS ONLY THAT IMSL TESTING HAS BEEN LI2F0660
C                           APPLIED TO THIS CODE. NO OTHER WARRANTY,    LI2F0670
C                           EXPRESSED OR IMPLIED, IS APPLICABLE.        LI2F0680
C                                                                       LI2F0690
C-----------------------------------------------------------------------LI2F0700
C                                                                       LI2F0710
      SUBROUTINE LINV2F (A,N,IA,AINV,IDGT,WKAREA,IER)                   LI2F0720
C                                                                       LI2F0730
      DOUBLE PRECISION   A(IA,N),AINV(IA,N),WKAREA(1),ZERO,ONE          LI2F0740
      DATA               ONE/1.0D0/,ZERO/0.0D0/                         LI2F0750
C                                  FIRST EXECUTABLE STATEMENT           LI2F0760
C                                  INITIALIZE IER                       LI2F0770
      IER=0                                                             LI2F0780
C                                  SET AINV TO THE N X N                LI2F0790
C                                  IDENTITY MATRIX                      LI2F0800
      DO 10 I = 1,N                                                     LI2F0810
         DO 5 J = 1,N                                                   LI2F0820
            AINV(I,J) = ZERO                                            LI2F0830
    5    CONTINUE                                                       LI2F0840
         AINV(I,I) = ONE                                                LI2F0850
   10 CONTINUE                                                          LI2F0860
C                                  COMPUTE THE INVERSE OF A             LI2F0870
      CALL LEQT2F (A,N,N,IA,AINV,IDGT,WKAREA,IER)                       LI2F0880
      IF (IER.EQ.0) GO TO 9005                                          LI2F0890
 9000 CONTINUE                                                          LI2F0900
CC    CALL UERTST (IER,6HLINV2F)                                        LI2F0910
 9005 RETURN                                                            LI2F0920
      END
*************************************************

C   IMSL ROUTINE NAME   - LEQT2F                                        LE2F0010
C                                                                       LE2F0020
C-----------------------------------------------------------------------LE2F0030
C                                                                       LE2F0040
C   COMPUTER            - VAX/DOUBLE                                    LE2F0050
C                                                                       LE2F0060
C   LATEST REVISION     - JUNE 1, 1982                                  LE2F0070
C                                                                       LE2F0080
C   PURPOSE             - LINEAR EQUATION SOLUTION - FULL STORAGE       LE2F0090
C                           MODE - HIGH ACCURACY SOLUTION               LE2F0100
C                                                                       LE2F0110
C   USAGE               - CALL LEQT2F (A,M,N,IA,B,IDGT,WKAREA,IER)      LE2F0120
C                                                                       LE2F0130
C   ARGUMENTS    A      - INPUT MATRIX OF DIMENSION N BY N CONTAINING   LE2F0140
C                           THE COEFFICIENT MATRIX OF THE EQUATION      LE2F0150
C                           AX = B.                                     LE2F0160
C                M      - NUMBER OF RIGHT-HAND SIDES. (INPUT)           LE2F0170
C                N      - ORDER OF A AND NUMBER OF ROWS IN B. (INPUT)   LE2F0180
C                IA     - ROW DIMENSION OF A AND B EXACTLY AS SPECIFIED LE2F0190
C                           IN THE DIMENSION STATEMENT IN THE CALLING   LE2F0200
C                           PROGRAM. (INPUT)                            LE2F0210
C                B      - INPUT MATRIX OF DIMENSION N BY M CONTAINING   LE2F0220
C                           THE RIGHT-HAND SIDES OF THE EQUATION AX = B.LE2F0230
C                           ON OUTPUT, THE N BY M MATRIX OF SOLUTIONS   LE2F0240
C                           REPLACES B.                                 LE2F0250
C                IDGT   - INPUT OPTION.                                 LE2F0260
C                         IF IDGT IS GREATER THAN 0, THE ELEMENTS OF    LE2F0270
C                           A AND B ARE ASSUMED TO BE CORRECT TO IDGT   LE2F0280
C                           DECIMAL DIGITS AND THE ROUTINE PERFORMS     LE2F0290
C                           AN ACCURACY TEST.                           LE2F0300
C                         IF IDGT EQUALS 0, THE ACCURACY TEST IS        LE2F0310
C                           BYPASSED.                                   LE2F0320
C                         ON OUTPUT, IDGT CONTAINS THE APPROXIMATE      LE2F0330
C                           NUMBER OF DIGITS IN THE ANSWER WHICH        LE2F0340
C                           WERE UNCHANGED AFTER IMPROVEMENT.           LE2F0350
C                WKAREA - WORK AREA OF DIMENSION GREATER THAN OR EQUAL  LE2F0360
C                           TO N**2+3N.                                 LE2F0370
C                IER    - ERROR PARAMETER. (OUTPUT)                     LE2F0380
C                         WARNING ERROR                                 LE2F0390
C                           IER = 34 INDICATES THAT THE ACCURACY TEST   LE2F0400
C                             FAILED. THE COMPUTED SOLUTION MAY BE IN   LE2F0410
C                             ERROR BY MORE THAN CAN BE ACCOUNTED FOR   LE2F0420
C                             BY THE UNCERTAINTY OF THE DATA. THIS      LE2F0430
C                             WARNING CAN BE PRODUCED ONLY IF IDGT IS   LE2F0440
C                             GREATER THAN 0 ON INPUT. (SEE THE         LE2F0450
C                             CHAPTER L PRELUDE FOR FURTHER DISCUSSION.)LE2F0460
C                         TERMINAL ERROR                                LE2F0470
C                           IER = 129 INDICATES THAT THE MATRIX IS      LE2F0480
C                             ALGORITHMICALLY SINGULAR. (SEE THE        LE2F0490
C                             CHAPTER L PRELUDE).                       LE2F0500
C                           IER = 131 INDICATES THAT THE MATRIX IS TOO  LE2F0510
C                             ILL-CONDITIONED FOR ITERATIVE IMPROVEMENT LE2F0520
C                             TO BE EFFECTIVE.                          LE2F0530
C                                                                       LE2F0540
C   PRECISION/HARDWARE  - SINGLE AND DOUBLE/H32                         LE2F0550
C                       - SINGLE/H36,H48,H60                            LE2F0560
C                                                                       LE2F0570
C   REQD. IMSL ROUTINES - SINGLE/LUDATN,LUELMN,LUREFN,UERTST,UGETIO     LE2F0580
C                       - DOUBLE/LUDATN,LUELMN,LUREFN,UERTST,UGETIO,    LE2F0590
C                           VXADD,VXMUL,VXSTO                           LE2F0600
C                                                                       LE2F0610
C   NOTATION            - INFORMATION ON SPECIAL NOTATION AND           LE2F0620
C                           CONVENTIONS IS AVAILABLE IN THE MANUAL      LE2F0630
C                           INTRODUCTION OR THROUGH IMSL ROUTINE UHELP  LE2F0640
C                                                                       LE2F0650
C   COPYRIGHT           - 1982 BY IMSL, INC. ALL RIGHTS RESERVED.       LE2F0660
C                                                                       LE2F0670
C   WARRANTY            - IMSL WARRANTS ONLY THAT IMSL TESTING HAS BEEN LE2F0680
C                           APPLIED TO THIS CODE. NO OTHER WARRANTY,    LE2F0690
C                           EXPRESSED OR IMPLIED, IS APPLICABLE.        LE2F0700
C                                                                       LE2F0710
C-----------------------------------------------------------------------LE2F0720
C                                                                       LE2F0730
      SUBROUTINE LEQT2F (A,M,N,IA,B,IDGT,WKAREA,IER)                    LE2F0740
C                                                                       LE2F0750
      DIMENSION          A(IA,1),B(IA,1),WKAREA(1)                      LE2F0760
      DOUBLE PRECISION   A,B,WKAREA,D1,D2,WA                            LE2F0770
C                                  FIRST EXECUTABLE STATEMENT           LE2F0780
C                                  INITIALIZE IER                       LE2F0790
      IER=0                                                             LE2F0800
      JER=0                                                             LE2F0810
      J = N*N+1                                                         LE2F0820
      K = J+N                                                           LE2F0830
      MM = K+N                                                          LE2F0840
      KK = 0                                                            LE2F0850
      MM1 = MM-1                                                        LE2F0860
      JJ=1                                                              LE2F0870
      DO 5 L=1,N                                                        LE2F0880
         DO 5 I=1,N                                                     LE2F0890
            WKAREA(JJ)=A(I,L)                                           LE2F0900
            JJ=JJ+1                                                     LE2F0910
    5 CONTINUE                                                          LE2F0920
C                                  DECOMPOSE A                          LE2F0930
      CALL LUDATN (WKAREA,N,N,A,IA,IDGT,D1,D2,WKAREA(J),WKAREA(K),      LE2F0940
     *             WA,IER)                                              LE2F0950
      IF (IER.GT.128) GO TO 25                                          LE2F0960
      IF (IDGT .EQ. 0 .OR. IER .NE. 0) KK = 1                           LE2F0970
      DO 15 I = 1,M                                                     LE2F0980
C                                  PERFORMS THE ELIMINATION PART OF     LE2F0990
C                                  AX = B                               LE2F1000
         CALL LUELMN (A,IA,N,B(1,I),WKAREA(J),WKAREA(MM))               LE2F1010
C                                  REFINEMENT OF SOLUTION TO AX = B     LE2F1020
         IF (KK .NE. 0)                                                 LE2F1030
     *   CALL LUREFN (WKAREA,N,N,A,IA,B(1,I),IDGT,WKAREA(J),WKAREA(MM), LE2F1040
     *                WKAREA(K),WKAREA(K),JER)                          LE2F1050
         DO 10 II=1,N                                                   LE2F1060
            B(II,I) = WKAREA(MM1+II)                                    LE2F1070
   10    CONTINUE                                                       LE2F1080
         IF (JER.NE.0) GO TO 20                                         LE2F1090
   15 CONTINUE                                                          LE2F1100
      GO TO 25                                                          LE2F1110
   20 IER = 131                                                         LE2F1120
   25 JJ=1                                                              LE2F1130
      DO 30 J = 1,N                                                     LE2F1140
         DO 30 I = 1,N                                                  LE2F1150
            A(I,J)=WKAREA(JJ)                                           LE2F1160
            JJ=JJ+1                                                     LE2F1170
   30 CONTINUE                                                          LE2F1180
      IF (IER .EQ. 0) GO TO 9005                                        LE2F1190
 9000 CONTINUE                                                          LE2F1200
CC    CALL UERTST (IER,6HLEQT2F)                                        LE2F1210
 9005 RETURN                                                            LE2F1220
      END
**************************************


C   IMSL ROUTINE NAME   - UERTST                                        UERT0010
C                                                                       UERT0020
C-----------------------------------------------------------------------UERT0030
C                                                                       UERT0040
C   COMPUTER            - VAX/SINGLE                                    UERT0050
C                                                                       UERT0060
C   LATEST REVISION     - JUNE 1, 1982                                  UERT0070
C                                                                       UERT0080
C   PURPOSE             - PRINT A MESSAGE REFLECTING AN ERROR CONDITION UERT0090
C                                                                       UERT0100
C   USAGE               - CALL UERTST (IER,NAME)                        UERT0110
C                                                                       UERT0120
C   ARGUMENTS    IER    - ERROR PARAMETER. (INPUT)                      UERT0130
C                           IER = I+J WHERE                             UERT0140
C                             I = 128 IMPLIES TERMINAL ERROR MESSAGE,   UERT0150
C                             I =  64 IMPLIES WARNING WITH FIX MESSAGE, UERT0160
C                             I =  32 IMPLIES WARNING MESSAGE.          UERT0170
C                             J = ERROR CODE RELEVANT TO CALLING        UERT0180
C                                 ROUTINE.                              UERT0190
C                NAME   - A CHARACTER STRING OF LENGTH SIX PROVIDING    UERT0200
C                           THE NAME OF THE CALLING ROUTINE. (INPUT)    UERT0210
C                                                                       UERT0220
C   PRECISION/HARDWARE  - SINGLE/ALL                                    UERT0230
C                                                                       UERT0240
C   REQD. IMSL ROUTINES - UGETIO,USPKD                                  UERT0250
C                                                                       UERT0260
C   NOTATION            - INFORMATION ON SPECIAL NOTATION AND           UERT0270
C                           CONVENTIONS IS AVAILABLE IN THE MANUAL      UERT0280
C                           INTRODUCTION OR THROUGH IMSL ROUTINE UHELP  UERT0290
C                                                                       UERT0300
C   REMARKS      THE ERROR MESSAGE PRODUCED BY UERTST IS WRITTEN        UERT0310
C                TO THE STANDARD OUTPUT UNIT. THE OUTPUT UNIT           UERT0320
C                NUMBER CAN BE DETERMINED BY CALLING UGETIO AS          UERT0330
C                FOLLOWS..   CALL UGETIO(1,NIN,NOUT).                   UERT0340
C                THE OUTPUT UNIT NUMBER CAN BE CHANGED BY CALLING       UERT0350
C                UGETIO AS FOLLOWS..                                    UERT0360
C                                NIN = 0                                UERT0370
C                                NOUT = NEW OUTPUT UNIT NUMBER          UERT0380
C                                CALL UGETIO(3,NIN,NOUT)                UERT0390
C                SEE THE UGETIO DOCUMENT FOR MORE DETAILS.              UERT0400
C                                                                       UERT0410
C   COPYRIGHT           - 1982 BY IMSL, INC. ALL RIGHTS RESERVED.       UERT0420
C                                                                       UERT0430
C   WARRANTY            - IMSL WARRANTS ONLY THAT IMSL TESTING HAS BEEN UERT0440
C                           APPLIED TO THIS CODE. NO OTHER WARRANTY,    UERT0450
C                           EXPRESSED OR IMPLIED, IS APPLICABLE.        UERT0460
C                                                                       UERT0470
C-----------------------------------------------------------------------UERT0480
C                                                                       UERT0490
      SUBROUTINE UERTST (IER,NAME)                                      UERT0500
C                                  SPECIFICATIONS FOR ARGUMENTS         UERT0510
      INTEGER            IER                                            UERT0520
      INTEGER            NAME(1)                                        UERT0530
C                                  SPECIFICATIONS FOR LOCAL VARIABLES   UERT0540
      INTEGER            I,IEQ,IEQDF,IOUNIT,LEVEL,LEVOLD,NAMEQ(6),      UERT0550
     *                   NAMSET(6),NAMUPK(6),NIN,NMTB                   UERT0560
      DATA               NAMSET/1HU,1HE,1HR,1HS,1HE,1HT/                UERT0570
      DATA               NAMEQ/6*1H /                                   UERT0580
      DATA               LEVEL/4/,IEQDF/0/,IEQ/1H=/                     UERT0590
C                                  UNPACK NAME INTO NAMUPK              UERT0600
C                                  FIRST EXECUTABLE STATEMENT           UERT0610
      CALL USPKD (NAME,6,NAMUPK,NMTB)                                   UERT0620
C                                  GET OUTPUT UNIT NUMBER               UERT0630
      CALL UGETIO(1,NIN,IOUNIT)                                         UERT0640
C                                  CHECK IER                            UERT0650
      IF (IER.GT.999) GO TO 25                                          UERT0660
      IF (IER.LT.-32) GO TO 55                                          UERT0670
      IF (IER.LE.128) GO TO 5                                           UERT0680
      IF (LEVEL.LT.1) GO TO 30                                          UERT0690
C                                  PRINT TERMINAL MESSAGE               UERT0700
      IF (IEQDF.EQ.1) WRITE(IOUNIT,35) IER,NAMEQ,IEQ,NAMUPK             UERT0710
      IF (IEQDF.EQ.0) WRITE(IOUNIT,35) IER,NAMUPK                       UERT0720
      GO TO 30                                                          UERT0730
    5 IF (IER.LE.64) GO TO 10                                           UERT0740
      IF (LEVEL.LT.2) GO TO 30                                          UERT0750
C                                  PRINT WARNING WITH FIX MESSAGE       UERT0760
      IF (IEQDF.EQ.1) WRITE(IOUNIT,40) IER,NAMEQ,IEQ,NAMUPK             UERT0770
      IF (IEQDF.EQ.0) WRITE(IOUNIT,40) IER,NAMUPK                       UERT0780
      GO TO 30                                                          UERT0790
   10 IF (IER.LE.32) GO TO 15                                           UERT0800
C                                  PRINT WARNING MESSAGE                UERT0810
      IF (LEVEL.LT.3) GO TO 30                                          UERT0820
      IF (IEQDF.EQ.1) WRITE(IOUNIT,45) IER,NAMEQ,IEQ,NAMUPK             UERT0830
      IF (IEQDF.EQ.0) WRITE(IOUNIT,45) IER,NAMUPK                       UERT0840
      GO TO 30                                                          UERT0850
   15 CONTINUE                                                          UERT0860
C                                  CHECK FOR UERSET CALL                UERT0870
      DO 20 I=1,6                                                       UERT0880
         IF (NAMUPK(I).NE.NAMSET(I)) GO TO 25                           UERT0890
   20 CONTINUE                                                          UERT0900
      LEVOLD = LEVEL                                                    UERT0910
      LEVEL = IER                                                       UERT0920
      IER = LEVOLD                                                      UERT0930
      IF (LEVEL.LT.0) LEVEL = 4                                         UERT0940
      IF (LEVEL.GT.4) LEVEL = 4                                         UERT0950
      GO TO 30                                                          UERT0960
   25 CONTINUE                                                          UERT0970
      IF (LEVEL.LT.4) GO TO 30                                          UERT0980
C                                  PRINT NON-DEFINED MESSAGE            UERT0990
      IF (IEQDF.EQ.1) WRITE(IOUNIT,50) IER,NAMEQ,IEQ,NAMUPK             UERT1000
      IF (IEQDF.EQ.0) WRITE(IOUNIT,50) IER,NAMUPK                       UERT1010
   30 IEQDF = 0                                                         UERT1020
      RETURN                                                            UERT1030
   35 FORMAT(19H *** TERMINAL ERROR,10X,7H(IER = ,I3,                   UERT1040
     1       20H) FROM IMSL ROUTINE ,6A1,A1,6A1)                        UERT1050
   40 FORMAT(27H *** WARNING WITH FIX ERROR,2X,7H(IER = ,I3,            UERT1060
     1       20H) FROM IMSL ROUTINE ,6A1,A1,6A1)                        UERT1070
   45 FORMAT(18H *** WARNING ERROR,11X,7H(IER = ,I3,                    UERT1080
     1       20H) FROM IMSL ROUTINE ,6A1,A1,6A1)                        UERT1090
   50 FORMAT(20H *** UNDEFINED ERROR,9X,7H(IER = ,I5,                   UERT1100
     1       20H) FROM IMSL ROUTINE ,6A1,A1,6A1)                        UERT1110
C                                                                       UERT1120
C                                  SAVE P FOR P = R CASE                UERT1130
C                                    P IS THE PAGE NAMUPK               UERT1140
C                                    R IS THE ROUTINE NAMUPK            UERT1150
   55 IEQDF = 1                                                         UERT1160
      DO 60 I=1,6                                                       UERT1170
   60 NAMEQ(I) = NAMUPK(I)                                              UERT1180
   65 RETURN                                                            UERT1190
      END
**************************************************
C   IMSL ROUTINE NAME   - USPKD                                         USPK0010
C                                                                       USPK0020
C-----------------------------------------------------------------------USPK0030
C                                                                       USPK0040
C   COMPUTER            - VAX/SINGLE                                    USPK0050
C                                                                       USPK0060
C   LATEST REVISION     - JUNE 1, 1982                                  USPK0070
C                                                                       USPK0080
C   PURPOSE             - NUCLEUS CALLED BY IMSL ROUTINES THAT HAVE     USPK0090
C                           CHARACTER STRING ARGUMENTS                  USPK0100
C                                                                       USPK0110
C   USAGE               - CALL USPKD  (PACKED,NCHARS,UNPAKD,NCHMTB)     USPK0120
C                                                                       USPK0130
C   ARGUMENTS    PACKED - CHARACTER STRING TO BE UNPACKED.(INPUT)       USPK0140
C                NCHARS - LENGTH OF PACKED. (INPUT)  SEE REMARKS.       USPK0150
C                UNPAKD - INTEGER ARRAY TO RECEIVE THE UNPACKED         USPK0160
C                         REPRESENTATION OF THE STRING. (OUTPUT)        USPK0170
C                NCHMTB - NCHARS MINUS TRAILING BLANKS. (OUTPUT)        USPK0180
C                                                                       USPK0190
C   PRECISION/HARDWARE  - SINGLE/ALL                                    USPK0200
C                                                                       USPK0210
C   REQD. IMSL ROUTINES - NONE                                          USPK0220
C                                                                       USPK0230
C   REMARKS  1.  USPKD UNPACKS A CHARACTER STRING INTO AN INTEGER ARRAY USPK0240
C                IN (A1) FORMAT.                                        USPK0250
C            2.  UP TO 129 CHARACTERS MAY BE USED.  ANY IN EXCESS OF    USPK0260
C                THAT ARE IGNORED.                                      USPK0270
C                                                                       USPK0280
C   COPYRIGHT           - 1982 BY IMSL, INC. ALL RIGHTS RESERVED.       USPK0290
C                                                                       USPK0300
C   WARRANTY            - IMSL WARRANTS ONLY THAT IMSL TESTING HAS BEEN USPK0310
C                           APPLIED TO THIS CODE. NO OTHER WARRANTY,    USPK0320
C                           EXPRESSED OR IMPLIED, IS APPLICABLE.        USPK0330
C                                                                       USPK0340
C-----------------------------------------------------------------------USPK0350
      SUBROUTINE USPKD  (PACKED,NCHARS,UNPAKD,NCHMTB)                   USPK0360
C                                  SPECIFICATIONS FOR ARGUMENTS         USPK0370
      INTEGER            NC,NCHARS,NCHMTB                               USPK0380
C                                                                       USPK0390
      INTEGER            UNPAKD(1),IBLANK                               USPK0400
      INTEGER            PACKED(1)                                      USPK0410
      DATA               IBLANK /1H /                                   USPK0420
C                                  INITIALIZE NCHMTB                    USPK0430
      NCHMTB = 0                                                        USPK0440
C                                  RETURN IF NCHARS IS LE ZERO          USPK0450
      IF(NCHARS.LE.0) RETURN                                            USPK0460
C                                  SET NC=NUMBER OF CHARS TO BE DECODED USPK0470
      NC = MIN0 (129,NCHARS)                                            USPK0480
CC    DECODE (NC,150,PACKED) (UNPAKD(I),I=1,NC)                         USPK0490
      DO I=1,NC
      UNPAKD(I)=0.
      ENDDO
  150 FORMAT (129A1)                                                    USPK0500
C                                  CHECK UNPAKD ARRAY AND SET NCHMTB    USPK0510
C                                  BASED ON TRAILING BLANKS FOUND       USPK0520
      DO 200 N = 1,NC                                                   USPK0530
         NN = NC - N + 1                                                USPK0540
         IF(UNPAKD(NN) .NE. IBLANK) GO TO 210                           USPK0550
  200 CONTINUE                                                          USPK0560
  210 NCHMTB = NN                                                       USPK0570
      RETURN                                                            USPK0580
      END
**********************************************
C   IMSL ROUTINE NAME   - UGETIO                                        UGET0010
C                                                                       UGET0020
C-----------------------------------------------------------------------UGET0030
C                                                                       UGET0040
C   COMPUTER            - VAX/SINGLE                                    UGET0050
C                                                                       UGET0060
C   LATEST REVISION     - JUNE 1, 1981                                  UGET0070
C                                                                       UGET0080
C   PURPOSE             - TO RETRIEVE CURRENT VALUES AND TO SET NEW     UGET0090
C                           VALUES FOR INPUT AND OUTPUT UNIT            UGET0100
C                           IDENTIFIERS.                                UGET0110
C                                                                       UGET0120
C   USAGE               - CALL UGETIO(IOPT,NIN,NOUT)                    UGET0130
C                                                                       UGET0140
C   ARGUMENTS    IOPT   - OPTION PARAMETER. (INPUT)                     UGET0150
C                           IF IOPT=1, THE CURRENT INPUT AND OUTPUT     UGET0160
C                           UNIT IDENTIFIER VALUES ARE RETURNED IN NIN  UGET0170
C                           AND NOUT, RESPECTIVELY.                     UGET0180
C                           IF IOPT=2, THE INTERNAL VALUE OF NIN IS     UGET0190
C                           RESET FOR SUBSEQUENT USE.                   UGET0200
C                           IF IOPT=3, THE INTERNAL VALUE OF NOUT IS    UGET0210
C                           RESET FOR SUBSEQUENT USE.                   UGET0220
C                NIN    - INPUT UNIT IDENTIFIER.                        UGET0230
C                           OUTPUT IF IOPT=1, INPUT IF IOPT=2.          UGET0240
C                NOUT   - OUTPUT UNIT IDENTIFIER.                       UGET0250
C                           OUTPUT IF IOPT=1, INPUT IF IOPT=3.          UGET0260
C                                                                       UGET0270
C   PRECISION/HARDWARE  - SINGLE/ALL                                    UGET0280
C                                                                       UGET0290
C   REQD. IMSL ROUTINES - NONE REQUIRED                                 UGET0300
C                                                                       UGET0310
C   NOTATION            - INFORMATION ON SPECIAL NOTATION AND           UGET0320
C                           CONVENTIONS IS AVAILABLE IN THE MANUAL      UGET0330
C                           INTRODUCTION OR THROUGH IMSL ROUTINE UHELP  UGET0340
C                                                                       UGET0350
C   REMARKS      EACH IMSL ROUTINE THAT PERFORMS INPUT AND/OR OUTPUT    UGET0360
C                OPERATIONS CALLS UGETIO TO OBTAIN THE CURRENT UNIT     UGET0370
C                IDENTIFIER VALUES. IF UGETIO IS CALLED WITH IOPT=2 OR  UGET0380
C                IOPT=3, NEW UNIT IDENTIFIER VALUES ARE ESTABLISHED.    UGET0390
C                SUBSEQUENT INPUT/OUTPUT IS PERFORMED ON THE NEW UNITS. UGET0400
C                                                                       UGET0410
C   COPYRIGHT           - 1978 BY IMSL, INC. ALL RIGHTS RESERVED.       UGET0420
C                                                                       UGET0430
C   WARRANTY            - IMSL WARRANTS ONLY THAT IMSL TESTING HAS BEEN UGET0440
C                           APPLIED TO THIS CODE. NO OTHER WARRANTY,    UGET0450
C                           EXPRESSED OR IMPLIED, IS APPLICABLE.        UGET0460
C                                                                       UGET0470
C-----------------------------------------------------------------------UGET0480
C                                                                       UGET0490
      SUBROUTINE UGETIO(IOPT,NIN,NOUT)                                  UGET0500
C                                  SPECIFICATIONS FOR ARGUMENTS         UGET0510
      INTEGER            IOPT,NIN,NOUT                                  UGET0520
C                                  SPECIFICATIONS FOR LOCAL VARIABLES   UGET0530
      INTEGER            NIND,NOUTD                                     UGET0540
      DATA               NIND/1/,NOUTD/2/                               UGET0550
C                                  FIRST EXECUTABLE STATEMENT           UGET0560
      IF (IOPT.EQ.3) GO TO 10                                           UGET0570
      IF (IOPT.EQ.2) GO TO 5                                            UGET0580
      IF (IOPT.NE.1) GO TO 9005                                         UGET0590
      NIN = NIND                                                        UGET0600
      NOUT = NOUTD                                                      UGET0610
      GO TO 9005                                                        UGET0620
    5 NIND = NIN                                                        UGET0630
      GO TO 9005                                                        UGET0640
   10 NOUTD = NOUT                                                      UGET0650
 9005 RETURN                                                            UGET0660
      END
********************************************
C   IMSL ROUTINE NAME   - LUDATN                                        LUDN0010
C                                                                       LUDN0020
C-----------------------------------------------------------------------LUDN0030
C                                                                       LUDN0040
C   COMPUTER            - VAX/DOUBLE                                    LUDN0050
C                                                                       LUDN0060
C   LATEST REVISION     - JUNE 1, 1982                                  LUDN0070
C                                                                       LUDN0080
C   PURPOSE             - NUCLEUS CALLED ONLY BY IMSL SUBROUTINE LEQT2F LUDN0090
C                                                                       LUDN0100
C   PRECISION/HARDWARE  - SINGLE AND DOUBLE/H32                         LUDN0110
C                       - SINGLE/H36,H48,H60                            LUDN0120
C                                                                       LUDN0130
C   REQD. IMSL ROUTINES - UERTST,UGETIO                                 LUDN0140
C                                                                       LUDN0150
C   NOTATION            - INFORMATION ON SPECIAL NOTATION AND           LUDN0160
C                           CONVENTIONS IS AVAILABLE IN THE MANUAL      LUDN0170
C                           INTRODUCTION OR THROUGH IMSL ROUTINE UHELP  LUDN0180
C                                                                       LUDN0190
C   COPYRIGHT           - 1982 BY IMSL, INC. ALL RIGHTS RESERVED.       LUDN0200
C                                                                       LUDN0210
C   WARRANTY            - IMSL WARRANTS ONLY THAT IMSL TESTING HAS BEEN LUDN0220
C                           APPLIED TO THIS CODE. NO OTHER WARRANTY,    LUDN0230
C                           EXPRESSED OR IMPLIED, IS APPLICABLE.        LUDN0240
C                                                                       LUDN0250
C-----------------------------------------------------------------------LUDN0260
C                                                                       LUDN0270
      SUBROUTINE LUDATN (A,IA,N,LU,ILU,IDGT,D1,D2,APVT,EQUIL,WA,IER)    LUDN0280
C                                                                       LUDN0290
      DIMENSION          A(IA,1),LU(ILU,1),APVT(1),EQUIL(1)             LUDN0300
      DOUBLE PRECISION   A,LU,D1,D2,EQUIL,WA,ZERO,ONE,FOUR,SIXTN,SIXTH, LUDN0310
     *                   RN,WREL,BIGA,BIG,P,SUM,AI,WI,T,TEST,Q,APVT     LUDN0320
      DATA               ZERO,ONE,FOUR,SIXTN,SIXTH/0.D0,1.D0,4.D0,      LUDN0330
     *                   16.D0,.0625D0/                                 LUDN0340
C                                  FIRST EXECUTABLE STATEMENT           LUDN0350
C                                  INITIALIZATION                       LUDN0360
      IER = 0                                                           LUDN0370
      RN = N                                                            LUDN0380
      WREL = ZERO                                                       LUDN0390
      D1 = ONE                                                          LUDN0400
      D2 = ZERO                                                         LUDN0410
      BIGA = ZERO                                                       LUDN0420
      DO 10 I=1,N                                                       LUDN0430
         BIG = ZERO                                                     LUDN0440
         DO 5 J=1,N                                                     LUDN0450
            P = A(I,J)                                                  LUDN0460
            LU(I,J) = P                                                 LUDN0470
            P = DABS(P)                                                 LUDN0480
            IF (P .GT. BIG) BIG = P                                     LUDN0490
    5    CONTINUE                                                       LUDN0500
         IF (BIG .GT. BIGA) BIGA = BIG                                  LUDN0510
         IF (BIG .EQ. ZERO) GO TO 110                                   LUDN0520
         EQUIL(I) = ONE/BIG                                             LUDN0530
   10 CONTINUE                                                          LUDN0540
      DO 105 J=1,N                                                      LUDN0550
         JM1 = J-1                                                      LUDN0560
         IF (JM1 .LT. 1) GO TO 40                                       LUDN0570
C                                  COMPUTE U(I,J), I=1,...,J-1          LUDN0580
         DO 35 I=1,JM1                                                  LUDN0590
            SUM = LU(I,J)                                               LUDN0600
            IM1 = I-1                                                   LUDN0610
            IF (IDGT .EQ. 0) GO TO 25                                   LUDN0620
C                                  WITH ACCURACY TEST                   LUDN0630
            AI = DABS(SUM)                                              LUDN0640
            WI = ZERO                                                   LUDN0650
            IF (IM1 .LT. 1) GO TO 20                                    LUDN0660
            DO 15 K=1,IM1                                               LUDN0670
               T = LU(I,K)*LU(K,J)                                      LUDN0680
               SUM = SUM-T                                              LUDN0690
               WI = WI+DABS(T)                                          LUDN0700
   15       CONTINUE                                                    LUDN0710
            LU(I,J) = SUM                                               LUDN0720
   20       WI = WI+DABS(SUM)                                           LUDN0730
            IF (AI .EQ. ZERO) AI = BIGA                                 LUDN0740
            TEST = WI/AI                                                LUDN0750
            IF (TEST .GT. WREL) WREL = TEST                             LUDN0760
            GO TO 35                                                    LUDN0770
C                                  WITHOUT ACCURACY                     LUDN0780
   25       IF (IM1 .LT. 1) GO TO 35                                    LUDN0790
            DO 30 K=1,IM1                                               LUDN0800
               SUM = SUM-LU(I,K)*LU(K,J)                                LUDN0810
   30       CONTINUE                                                    LUDN0820
            LU(I,J) = SUM                                               LUDN0830
   35    CONTINUE                                                       LUDN0840
   40    P = ZERO                                                       LUDN0850
C                                  COMPUTE U(J,J) AND L(I,J), I=J+1,...,LUDN0860
         DO 70 I=J,N                                                    LUDN0870
            SUM = LU(I,J)                                               LUDN0880
            IF (IDGT .EQ. 0) GO TO 55                                   LUDN0890
C                                  WITH ACCURACY TEST                   LUDN0900
            AI = DABS(SUM)                                              LUDN0910
            WI = ZERO                                                   LUDN0920
            IF (JM1 .LT. 1) GO TO 50                                    LUDN0930
            DO 45 K=1,JM1                                               LUDN0940
               T = LU(I,K)*LU(K,J)                                      LUDN0950
               SUM = SUM-T                                              LUDN0960
               WI = WI+DABS(T)                                          LUDN0970
   45       CONTINUE                                                    LUDN0980
            LU(I,J) = SUM                                               LUDN0990
   50       WI = WI+DABS(SUM)                                           LUDN1000
            IF (AI .EQ. ZERO) AI = BIGA                                 LUDN1010
            TEST = WI/AI                                                LUDN1020
            IF (TEST .GT. WREL) WREL = TEST                             LUDN1030
            GO TO 65                                                    LUDN1040
C                                  WITHOUT ACCURACY TEST                LUDN1050
   55       IF (JM1 .LT. 1) GO TO 65                                    LUDN1060
            DO 60 K=1,JM1                                               LUDN1070
               SUM = SUM-LU(I,K)*LU(K,J)                                LUDN1080
   60       CONTINUE                                                    LUDN1090
            LU(I,J) = SUM                                               LUDN1100
   65       Q = EQUIL(I)*DABS(SUM)                                      LUDN1110
            IF (P .GE. Q) GO TO 70                                      LUDN1120
            P = Q                                                       LUDN1130
            IMAX = I                                                    LUDN1140
   70    CONTINUE                                                       LUDN1150
C                                  TEST FOR ALGORITHMIC SINGULARITY     LUDN1160
         IF (RN+P .EQ. RN) GO TO 110                                    LUDN1170
         IF (J .EQ. IMAX) GO TO 80                                      LUDN1180
C                                  INTERCHANGE ROWS J AND IMAX          LUDN1190
         D1 = -D1                                                       LUDN1200
         DO 75 K=1,N                                                    LUDN1210
            P = LU(IMAX,K)                                              LUDN1220
            LU(IMAX,K) = LU(J,K)                                        LUDN1230
            LU(J,K) = P                                                 LUDN1240
   75    CONTINUE                                                       LUDN1250
         EQUIL(IMAX) = EQUIL(J)                                         LUDN1260
   80    APVT(J) = IMAX                                                 LUDN1270
         D1 = D1*LU(J,J)                                                LUDN1280
   85    IF (DABS(D1) .LE. ONE) GO TO 90                                LUDN1290
         D1 = D1*SIXTH                                                  LUDN1300
         D2 = D2+FOUR                                                   LUDN1310
         GO TO 85                                                       LUDN1320
   90    IF (DABS(D1) .GE. SIXTH) GO TO 95                              LUDN1330
         D1 = D1*SIXTN                                                  LUDN1340
         D2 = D2-FOUR                                                   LUDN1350
         GO TO 90                                                       LUDN1360
   95    CONTINUE                                                       LUDN1370
         JP1 = J+1                                                      LUDN1380
         IF (JP1 .GT. N) GO TO 105                                      LUDN1390
C                                  DIVIDE BY PIVOT ELEMENT U(J,J)       LUDN1400
         P = LU(J,J)                                                    LUDN1410
         DO 100 I=JP1,N                                                 LUDN1420
            LU(I,J) = LU(I,J)/P                                         LUDN1430
  100    CONTINUE                                                       LUDN1440
  105 CONTINUE                                                          LUDN1450
C                                  PERFORM ACCURACY TEST                LUDN1460
      IF (IDGT .EQ. 0) GO TO 9005                                       LUDN1470
      P = 3*N+3                                                         LUDN1480
      WA = P*WREL                                                       LUDN1490
      IF (WA+10.D0**(-IDGT) .NE. WA) GO TO 9005                         LUDN1500
      IER = 34                                                          LUDN1510
      GO TO 9000                                                        LUDN1520
C                                  ALGORITHMIC SINGULARITY              LUDN1530
  110 IER = 129                                                         LUDN1540
      D1 = ZERO                                                         LUDN1550
      D2 = ZERO                                                         LUDN1560
 9000 CONTINUE                                                          LUDN1570
C                                  PRINT ERROR                          LUDN1580
      CALL UERTST(IER,6HLUDATN)                                         LUDN1590
 9005 RETURN                                                            LUDN1600
      END
******************************************
C   IMSL ROUTINE NAME   - LUELMN                                        LUEN0010
C                                                                       LUEN0020
C-----------------------------------------------------------------------LUEN0030
C                                                                       LUEN0040
C   COMPUTER            - VAX/DOUBLE                                    LUEN0050
C                                                                       LUEN0060
C   LATEST REVISION     - JUNE 1, 1982                                  LUEN0070
C                                                                       LUEN0080
C   PURPOSE             - NUCLEUS CALLED ONLY BY IMSL SUBROUTINE LEQT2F LUEN0090
C                                                                       LUEN0100
C   REQD. IMSL ROUTINES - NONE REQUIRED                                 LUEN0110
C                                                                       LUEN0120
C   NOTATION            - INFORMATION ON SPECIAL NOTATION AND           LUEN0130
C                           CONVENTIONS IS AVAILABLE IN THE MANUAL      LUEN0140
C                           INTRODUCTION OR THROUGH IMSL ROUTINE UHELP  LUEN0150
C                                                                       LUEN0160
C   COPYRIGHT           - 1982 BY IMSL, INC. ALL RIGHTS RESERVED.       LUEN0170
C                                                                       LUEN0180
C   WARRANTY            - IMSL WARRANTS ONLY THAT IMSL TESTING HAS BEEN LUEN0190
C                           APPLIED TO THIS CODE. NO OTHER WARRANTY,    LUEN0200
C                           EXPRESSED OR IMPLIED, IS APPLICABLE.        LUEN0210
C                                                                       LUEN0220
C-----------------------------------------------------------------------LUEN0230
C                                                                       LUEN0240
      SUBROUTINE LUELMN (A,IA,N,B,APVT,X)                               LUEN0250
C                                                                       LUEN0260
      DIMENSION          A(IA,1),B(1),APVT(1),X(1)                      LUEN0270
      DOUBLE PRECISION   A,B,X,SUM,APVT                                 LUEN0280
C                                  FIRST EXECUTABLE STATEMENT           LUEN0290
C                                  SOLVE LY = B FOR Y                   LUEN0300
      DO 5 I=1,N                                                        LUEN0310
    5 X(I) = B(I)                                                       LUEN0320
      IW = 0                                                            LUEN0330
      DO 20 I=1,N                                                       LUEN0340
         IP = APVT(I)                                                   LUEN0350
         SUM = X(IP)                                                    LUEN0360
         X(IP) = X(I)                                                   LUEN0370
         IF (IW .EQ. 0) GO TO 15                                        LUEN0380
         IM1 = I-1                                                      LUEN0390
         DO 10 J=IW,IM1                                                 LUEN0400
            SUM = SUM-A(I,J)*X(J)                                       LUEN0410
   10    CONTINUE                                                       LUEN0420
         GO TO 20                                                       LUEN0430
   15    IF (SUM .NE. 0.D0) IW = I                                      LUEN0440
   20 X(I) = SUM                                                        LUEN0450
C                                  SOLVE UX = Y FOR X                   LUEN0460
      DO 30 IB=1,N                                                      LUEN0470
         I = N+1-IB                                                     LUEN0480
         IP1 = I+1                                                      LUEN0490
         SUM = X(I)                                                     LUEN0500
         IF (IP1 .GT. N) GO TO 30                                       LUEN0510
         DO 25 J=IP1,N                                                  LUEN0520
            SUM = SUM-A(I,J)*X(J)                                       LUEN0530
   25   CONTINUE                                                        LUEN0540
   30 X(I) = SUM/A(I,I)                                                 LUEN0550
      RETURN                                                            LUEN0560
      END
***************************************


C   IMSL ROUTINE NAME   - LUREFN                                        LURN0010
C                                                                       LURN0020
C-----------------------------------------------------------------------LURN0030
C                                                                       LURN0040
C   COMPUTER            - VAX/DOUBLE                                    LURN0050
C                                                                       LURN0060
C   LATEST REVISION     - JUNE 1, 1982                                  LURN0070
C                                                                       LURN0080
C   PURPOSE             - NUCLEUS CALLED ONLY BY IMSL SUBROUTINE LEQT2F LURN0090
C                                                                       LURN0100
C   PRECISION/HARDWARE  - SINGLE AND DOUBLE/H32                         LURN0110
C                       - SINGLE/H36,H48,H60                            LURN0120
C                                                                       LURN0130
C   REQD. IMSL ROUTINES - SINGLE/LUELMN,UERTST,UGETIO                   LURN0140
C                       - DOUBLE/LUELMN,UERTST,UGETIO,VXADD,VXMUL,      LURN0150
C                           VXSTO                                       LURN0160
C                                                                       LURN0170
C   NOTATION            - INFORMATION ON SPECIAL NOTATION AND           LURN0180
C                           CONVENTIONS IS AVAILABLE IN THE MANUAL      LURN0190
C                           INTRODUCTION OR THROUGH IMSL ROUTINE UHELP  LURN0200
C                                                                       LURN0210
C   COPYRIGHT           - 1982 BY IMSL, INC. ALL RIGHTS RESERVED.       LURN0220
C                                                                       LURN0230
C   WARRANTY            - IMSL WARRANTS ONLY THAT IMSL TESTING HAS BEEN LURN0240
C                           APPLIED TO THIS CODE. NO OTHER WARRANTY,    LURN0250
C                           EXPRESSED OR IMPLIED, IS APPLICABLE.        LURN0260
C                                                                       LURN0270
C-----------------------------------------------------------------------LURN0280
C                                                                       LURN0290
      SUBROUTINE LUREFN (A,IA,N,UL,IUL,B,IDGT,APVT,X,RES,DX,IER)        LURN0300
C                                                                       LURN0310
      DIMENSION          A(IA,1),UL(IUL,1),B(1),X(1),RES(1),DX(1)       LURN0320
      DIMENSION          APVT(1)                                        LURN0330
      DIMENSION          ACCXT(2)                                       LURN0340
      DOUBLE PRECISION   A,ACCXT,B,UL,X,RES,DX,ZERO,XNORM,DXNORM,APVT   LURN0350
      DATA               ITMAX/75/,ZERO/0.D0/                           LURN0360
C                                  FIRST EXECUTABLE STATEMENT           LURN0370
      IER=0                                                             LURN0380
      XNORM = ZERO                                                      LURN0390
      DO 10 I=1,N                                                       LURN0400
         XNORM = DMAX1(XNORM,DABS(X(I)))                                LURN0410
   10 CONTINUE                                                          LURN0420
      IF (XNORM .NE. ZERO) GO TO 20                                     LURN0430
      IDGT = 50                                                         LURN0440
      GO TO 9005                                                        LURN0450
   20 DO 45 ITER=1,ITMAX                                                LURN0460
         DO 30 I=1,N                                                    LURN0470
      ACCXT(1) = 0.0D0                                                  LURN0480
      ACCXT(2) = 0.0D0                                                  LURN0490
            CALL VXADD(B(I),ACCXT)                                      LURN0500
            DO 25 J=1,N                                                 LURN0510
               CALL VXMUL(-A(I,J),X(J),ACCXT)                           LURN0520
   25       CONTINUE                                                    LURN0530
            CALL VXSTO(ACCXT,RES(I))                                    LURN0540
   30    CONTINUE                                                       LURN0550
         CALL LUELMN (UL,IUL,N,RES,APVT,DX)                             LURN0560
         DXNORM = ZERO                                                  LURN0570
         XNORM = ZERO                                                   LURN0580
         DO 35 I=1,N                                                    LURN0590
            X(I) = X(I) + DX(I)                                         LURN0600
            DXNORM = DMAX1(DXNORM,DABS(DX(I)))                          LURN0610
            XNORM = DMAX1(XNORM,DABS(X(I)))                             LURN0620
   35    CONTINUE                                                       LURN0630
         IF (ITER .NE. 1) GO TO 40                                      LURN0640
         IDGT = 50                                                      LURN0650
         IF (DXNORM .NE. ZERO) IDGT = -DLOG10(DXNORM/XNORM)             LURN0660
   40    IF (XNORM+DXNORM .EQ. XNORM) GO TO 9005                        LURN0670
   45 CONTINUE                                                          LURN0680
C                                  ITERATION DID NOT CONVERGE           LURN0690
      IER = 129                                                         LURN0700
 9000 CONTINUE                                                          LURN0710
      CALL UERTST(IER,6HLUREFN)                                         LURN0720
 9005 RETURN                                                            LURN0730
      END
**********************************
C   IMSL ROUTINE NAME   - VXADD                                         VXAD0010
C                                                                       VXAD0020
C-----------------------------------------------------------------------VXAD0030
C                                                                       VXAD0040
C   COMPUTER            - VAX/DOUBLE                                    VXAD0050
C                                                                       VXAD0060
C   LATEST REVISION     - JANUARY 1, 1978                               VXAD0070
C                                                                       VXAD0080
C   PURPOSE             - EXTENDED PRECISION ADD                        VXAD0090
C                                                                       VXAD0100
C   USAGE               - CALL VXADD (A,ACC)                            VXAD0110
C                                                                       VXAD0120
C   ARGUMENTS    A      - DOUBLE PRECISION NUMBER TO BE ADDED TO THE    VXAD0130
C                           ACCUMULATOR. (INPUT)                        VXAD0140
C                ACC    - ACCUMULATOR. (INPUT AND OUTPUT)               VXAD0150
C                           ACC IS A DOUBLE PRECISION VECTOR OF LENGTH  VXAD0160
C                           2. ON OUTPUT, ACC CONTAINS THE SUM OF       VXAD0170
C                           INPUT ACC AND A.                            VXAD0180
C                                                                       VXAD0190
C   PRECISION/HARDWARE  - DOUBLE/H32                                    VXAD0200
C                       - NOT AVAILABLE/H36,H48,H60                     VXAD0210
C                                                                       VXAD0220
C   REQD. IMSL ROUTINES - NONE REQUIRED                                 VXAD0230
C                                                                       VXAD0240
C   NOTATION            - INFORMATION ON SPECIAL NOTATION AND           VXAD0250
C                           CONVENTIONS IS AVAILABLE IN THE MANUAL      VXAD0260
C                           INTRODUCTION OR THROUGH IMSL ROUTINE UHELP  VXAD0270
C                                                                       VXAD0280
C   REMARKS      VXADD ADDS THE DOUBLE PRECISION NUMBER A TO THE        VXAD0290
C                EXTENDED PRECISION ACCUMULATOR, ACC. THE SUBROUTINE    VXAD0300
C                ASSUMES THAT AN EXTENDED PRECISION NUMBER IS ALREADY INVXAD0310
C                THE ACCUMULATOR. THEREFORE, BEFORE THE FIRST CALL TO   VXAD0320
C                VXADD, ACC(1) AND ACC(2) MUST BE SET TO ZERO.          VXAD0330
C                                                                       VXAD0340
C   COPYRIGHT           - 1978 BY IMSL, INC. ALL RIGHTS RESERVED.       VXAD0350
C                                                                       VXAD0360
C   WARRANTY            - IMSL WARRANTS ONLY THAT IMSL TESTING HAS BEEN VXAD0370
C                           APPLIED TO THIS CODE. NO OTHER WARRANTY,    VXAD0380
C                           EXPRESSED OR IMPLIED, IS APPLICABLE.        VXAD0390
C                                                                       VXAD0400
C-----------------------------------------------------------------------VXAD0410
C                                                                       VXAD0420
      SUBROUTINE VXADD(A,ACC)                                           VXAD0430
C                                                                       VXAD0440
C                                  SPECIFICATIONS FOR ARGUMENTS         VXAD0450
      DOUBLE PRECISION   A,ACC(2)                                       VXAD0460
C                                  SPECIFICATIONS FOR LOCAL VARIABLES   VXAD0470
      DOUBLE PRECISION   X,Y,Z,ZZ                                       VXAD0480
C                                  FIRST EXECUTABLE STATEMENT           VXAD0490
      X = ACC(1)                                                        VXAD0500
      Y = A                                                             VXAD0510
      IF (DABS(ACC(1)).GE.DABS(A)) GO TO 1                              VXAD0520
      X = A                                                             VXAD0530
      Y = ACC(1)                                                        VXAD0540
C                                  COMPUTE Z+ZZ = ACC(1)+A EXACTLY      VXAD0550
    1 Z = X+Y                                                           VXAD0560
      IF (DSIGN(1.0D0,X).NE.DSIGN(1.0D0,Y)) GO TO 5                     VXAD0570
      ZZ = (0.46D0*Z-Z)+Z                                               VXAD0580
      ZZ = ((X-ZZ)-(Z-ZZ))+Y                                            VXAD0590
      GO TO 10                                                          VXAD0600
    5 CONTINUE                                                          VXAD0610
      ZZ = (X-Z)+Y                                                      VXAD0620
C                                  COMPUTE ZZ+ACC(2) USING DOUBLE       VXAD0630
C                                    PRECISION ARITHMETIC               VXAD0640
   10 CONTINUE                                                          VXAD0650
      ZZ = ZZ+ACC(2)                                                    VXAD0660
C                                  COMPUTE ACC(1)+ACC(2) = Z+ZZ EXACTLY VXAD0670
      ACC(1) = Z+ZZ                                                     VXAD0680
      IF (DSIGN(1.0D0,Z).NE.DSIGN(1.0D0,ZZ)) GO TO 15                   VXAD0690
      X = (0.46D0*ACC(1)-ACC(1))+ACC(1)                                 VXAD0700
      ACC(2) = ((Z-X)-(ACC(1)-X))+ZZ                                    VXAD0710
      GO TO 20                                                          VXAD0720
   15 CONTINUE                                                          VXAD0730
      ACC(2) = (Z-ACC(1))+ZZ                                            VXAD0740
   20 CONTINUE                                                          VXAD0750
      RETURN                                                            VXAD0760
      END
*******************************************
C   IMSL ROUTINE NAME   - VXMUL                                         VXMU0010
C                                                                       VXMU0020
C-----------------------------------------------------------------------VXMU0030
C                                                                       VXMU0040
C   COMPUTER            - VAX/DOUBLE                                    VXMU0050
C                                                                       VXMU0060
C   LATEST REVISION     - JUNE 1, 1981                                  VXMU0070
C                                                                       VXMU0080
C   PURPOSE             - EXTENDED PRECISION MULTIPLY                   VXMU0090
C                                                                       VXMU0100
C   USAGE               - CALL VXMUL (A,B,ACC)                          VXMU0110
C                                                                       VXMU0120
C   ARGUMENTS    A      - INPUT DOUBLE PRECISION NUMBER                 VXMU0130
C                B      - INPUT DOUBLE PRECISION NUMBER                 VXMU0140
C                ACC    - ACCUMULATOR. (INPUT AND OUTPUT)               VXMU0150
C                           ACC IS A DOUBLE PRECISION VECTOR OF LENGTH  VXMU0160
C                           2.  ON OUTPUT, ACC CONTAINS THE SUM OF      VXMU0170
C                           INPUT ACC AND A*B.                          VXMU0180
C                                                                       VXMU0190
C   PRECISION/HARDWARE  - DOUBLE/H32                                    VXMU0200
C                       - NOT AVAILABLE/H36,H48,H60                     VXMU0210
C                                                                       VXMU0220
C   REQD. IMSL ROUTINES - VXADD                                         VXMU0230
C                                                                       VXMU0240
C   NOTATION            - INFORMATION ON SPECIAL NOTATION AND           VXMU0250
C                           CONVENTIONS IS AVAILABLE IN THE MANUAL      VXMU0260
C                           INTRODUCTION OR THROUGH IMSL ROUTINE UHELP  VXMU0270
C                                                                       VXMU0280
C   REMARKS      VXMUL ADDS THE PRODUCT A*B TO THE EXTENDED PRECISION   VXMU0290
C                ACCUMULATOR, ACC. THE SUBROUTINE ASSUMES THAT AN       VXMU0300
C                EXTENDED PRECISION NUMBER IS ALREADY IN THE            VXMU0310
C                ACCUMULATOR.  THEREFORE, BEFORE THE FIRST CALL TO      VXMU0320
C                VXMUL, ACC(1) AND ACC(2) MUST BE SET TO ZERO.          VXMU0330
C                                                                       VXMU0340
C   COPYRIGHT           - 1978 BY IMSL, INC. ALL RIGHTS RESERVED.       VXMU0350
C                                                                       VXMU0360
C   WARRANTY            - IMSL WARRANTS ONLY THAT IMSL TESTING HAS BEEN VXMU0370
C                           APPLIED TO THIS CODE. NO OTHER WARRANTY,    VXMU0380
C                           EXPRESSED OR IMPLIED, IS APPLICABLE.        VXMU0390
C                                                                       VXMU0400
C-----------------------------------------------------------------------VXMU0410
C                                                                       VXMU0420
      SUBROUTINE VXMUL (A,B,ACC)                                        VXMU0430
C                                  SPECIFICATIONS FOR ARGUMENTS         VXMU0440
      DOUBLE PRECISION   A,B,ACC(2)                                     VXMU0450
C                                  SPECIFICATIONS FOR LOCAL VARIABLES   VXMU0460
      DOUBLE PRECISION   X,HA,TA,HB,TB                                  VXMU0470
      INTEGER            IX(2)                                          VXMU0480
      EQUIVALENCE        (X,IX(1))                                      VXMU0490
      DATA               I/0/                                           VXMU0500
C                                  SPLIT A = HA+TA                      VXMU0510
C                                        B = HB+TB                      VXMU0520
C                                  FIRST EXECUTABLE STATEMENT           VXMU0530
      X = A                                                             VXMU0540
CC    IX(2) = IX(2).AND.(-268435456)                                    VXMU0550
      HA=X                                                              VXMU0560
      TA=A-HA                                                           VXMU0570
      X = B                                                             VXMU0580
CC    IX(2) = IX(2).AND.(-268435456)                                    VXMU0590
      HB = X                                                            VXMU0600
      TB = B-HB                                                         VXMU0610
C                                  COMPUTE HA*HB,HA*TB,TA*HB, AND TA*TB VXMU0620
C                                    AND CALL VXADD TO ACCUMULATE THE   VXMU0630
C                                    SUM                                VXMU0640
      X = TA*TB                                                         VXMU0650
      CALL VXADD(X,ACC)                                                 VXMU0660
      X = HA*TB                                                         VXMU0670
      CALL VXADD(X,ACC)                                                 VXMU0680
      X = TA*HB                                                         VXMU0690
      CALL VXADD(X,ACC)                                                 VXMU0700
      X = HA*HB                                                         VXMU0710
      CALL VXADD(X,ACC)                                                 VXMU0720
      RETURN                                                            VXMU0730
      END
*****************************************
C   IMSL ROUTINE NAME   - VXSTO                                         VXST0010
C                                                                       VXST0020
C-----------------------------------------------------------------------VXST0030
C                                                                       VXST0040
C   COMPUTER            - VAX/DOUBLE                                    VXST0050
C                                                                       VXST0060
C   LATEST REVISION     - JANUARY 1, 1978                               VXST0070
C                                                                       VXST0080
C   PURPOSE             - DOUBLE PRECISION STORE.                       VXST0090
C                                                                       VXST0100
C   USAGE               - CALL VXSTO(ACC,D)                             VXST0110
C                                                                       VXST0120
C   ARGUMENTS    ACC    - ACCUMULATOR. (INPUT)                          VXST0130
C                           ACC IS A DOUBLE PRECISION VECTOR OF LENGTH  VXST0140
C                           2. ACC IS ASSUMED TO BE THE RESULT OF       VXST0150
C                           CALLING VXADD OR VXMUL TO PERFORM EXTENDED  VXST0160
C                           PRECISION OPERATIONS.                       VXST0170
C                D      - DOUBLE PRECISION SCALAR. (OUTPUT)             VXST0180
C                           ON OUTPUT, D CONTAINS A DOUBLE PRECISION    VXST0190
C                           APPROXIMATION TO THE VALUE OF THE EXTENDED  VXST0200
C                           PRECISION ACCUMULATOR.                      VXST0210
C                                                                       VXST0220
C   PRECISION/HARDWARE  - DOUBLE/H32                                    VXST0230
C                       - NOT AVAILABLE/H36,H48,H60                     VXST0240
C                                                                       VXST0250
C   REQD. IMSL ROUTINES - NONE REQUIRED                                 VXST0260
C                                                                       VXST0270
C   NOTATION            - INFORMATION ON SPECIAL NOTATION AND           VXST0280
C                           CONVENTIONS IS AVAILABLE IN THE MANUAL      VXST0290
C                           INTRODUCTION OR THROUGH IMSL ROUTINE UHELP  VXST0300
C                                                                       VXST0310
C   COPYRIGHT           - 1978 BY IMSL, INC. ALL RIGHTS RESERVED.       VXST0320
C                                                                       VXST0330
C   WARRANTY            - IMSL WARRANTS ONLY THAT IMSL TESTING HAS BEEN VXST0340
C                           APPLIED TO THIS CODE. NO OTHER WARRANTY,    VXST0350
C                           EXPRESSED OR IMPLIED, IS APPLICABLE.        VXST0360
C                                                                       VXST0370
C-----------------------------------------------------------------------VXST0380
C                                                                       VXST0390
      SUBROUTINE VXSTO (ACC,D)                                          VXST0400
C                                  SPECIFICATIONS FOR ARGUMENTS         VXST0410
      DOUBLE PRECISION   ACC(2),D                                       VXST0420
C                                  FIRST EXECUTABLE STATEMENT           VXST0430
      D = ACC(1)+ACC(2)                                                 VXST0440
      RETURN                                                            VXST0450
      END
